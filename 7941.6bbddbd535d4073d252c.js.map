{"version":3,"file":"7941.6bbddbd535d4073d252c.js","mappings":"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","sources":["webpack://telegram-t/./src/util/WorkerConnector.ts","webpack://telegram-t/./src/lib/rlottie/RLottie.ts","webpack://telegram-t/./src/util/cycleRestrict.ts"],"sourcesContent":["import generateIdFor from './generateIdFor';\n\nexport interface CancellableCallback {\n  (\n    ...args: any[]\n  ): void;\n\n  isCanceled?: boolean;\n  acceptsBuffer?: boolean;\n}\n\ntype CallMethodData = {\n  type: 'callMethod';\n  messageId?: string;\n  name: string;\n  args: any;\n  withCallback?: boolean;\n};\n\ntype OriginMessageData = CallMethodData | {\n  type: 'cancelProgress';\n  messageId: string;\n};\n\nexport interface OriginMessageEvent {\n  data: OriginMessageData;\n}\n\nexport type WorkerMessageData = {\n  type: 'methodResponse';\n  messageId: string;\n  response?: any;\n  error?: { message: string };\n} | {\n  type: 'methodCallback';\n  messageId: string;\n  callbackArgs: any[];\n} | {\n  type: 'unhandledError';\n  error?: { message: string };\n};\n\nexport interface WorkerMessageEvent {\n  data: WorkerMessageData;\n}\n\ninterface RequestStates {\n  messageId: string;\n  resolve: Function;\n  reject: Function;\n  callback: AnyToVoidFunction;\n}\n\n// TODO Replace `any` with proper generics\nexport default class WorkerConnector {\n  private requestStates = new Map<string, RequestStates>();\n\n  private requestStatesByCallback = new Map<AnyToVoidFunction, RequestStates>();\n\n  constructor(private worker: Worker) {\n    this.subscribe();\n  }\n\n  request(messageData: { name: string; args: any }) {\n    const { worker, requestStates, requestStatesByCallback } = this;\n\n    const messageId = generateIdFor(requestStates);\n    const payload: CallMethodData = {\n      type: 'callMethod',\n      messageId,\n      ...messageData,\n    };\n\n    const requestState = { messageId } as RequestStates;\n\n    // Re-wrap type because of `postMessage`\n    const promise: Promise<any> = new Promise((resolve, reject) => {\n      Object.assign(requestState, { resolve, reject });\n    });\n\n    if (typeof payload.args[payload.args.length - 1] === 'function') {\n      payload.withCallback = true;\n\n      const callback = payload.args.pop() as AnyToVoidFunction;\n      requestState.callback = callback;\n      requestStatesByCallback.set(callback, requestState);\n    }\n\n    requestStates.set(messageId, requestState);\n    promise\n      .catch(() => undefined)\n      .finally(() => {\n        requestStates.delete(messageId);\n\n        if (requestState.callback) {\n          requestStatesByCallback.delete(requestState.callback);\n        }\n      });\n\n    worker.postMessage(payload);\n\n    return promise;\n  }\n\n  cancelCallback(progressCallback: CancellableCallback) {\n    progressCallback.isCanceled = true;\n\n    const { messageId } = this.requestStatesByCallback.get(progressCallback) || {};\n    if (!messageId) {\n      return;\n    }\n\n    this.worker.postMessage({\n      type: 'cancelProgress',\n      messageId,\n    });\n  }\n\n  private subscribe() {\n    const { worker, requestStates } = this;\n\n    worker.addEventListener('message', ({ data }: WorkerMessageEvent) => {\n      if (data.type === 'methodResponse') {\n        const requestState = requestStates.get(data.messageId);\n        if (requestState) {\n          if (data.error) {\n            requestState.reject(data.error);\n          } else {\n            requestState.resolve(data.response);\n          }\n        }\n      } else if (data.type === 'methodCallback') {\n        const requestState = requestStates.get(data.messageId);\n        requestState?.callback?.(...data.callbackArgs);\n      } else if (data.type === 'unhandledError') {\n        throw new Error(data.error?.message);\n      }\n    });\n  }\n}\n","import {\n  DPR,\n  IS_SINGLE_COLUMN_LAYOUT,\n  IS_SAFARI,\n  IS_ANDROID,\n} from '../../util/environment';\nimport WorkerConnector from '../../util/WorkerConnector';\nimport { animate } from '../../util/animation';\nimport cycleRestrict from '../../util/cycleRestrict';\n\ninterface Params {\n  noLoop?: boolean;\n  size?: number;\n  quality?: number;\n  isLowPriority?: boolean;\n}\n\ntype Frames = ArrayBuffer[];\ntype Chunks = (Frames | undefined)[];\n\n// TODO Consider removing chunks\nconst CHUNK_SIZE = 1;\nconst MAX_WORKERS = 4;\nconst HIGH_PRIORITY_QUALITY = IS_SINGLE_COLUMN_LAYOUT ? 0.75 : 1;\nconst LOW_PRIORITY_QUALITY = IS_ANDROID ? 0.5 : 0.75;\nconst HIGH_PRIORITY_CACHE_MODULO = IS_SAFARI ? 2 : 4;\nconst LOW_PRIORITY_CACHE_MODULO = 0;\n\nconst instancesById = new Map<string, RLottie>();\n\nconst workers = new Array(MAX_WORKERS).fill(undefined).map(\n  () => new WorkerConnector(new Worker(new URL('./rlottie.worker.ts', import.meta.url))),\n);\nlet lastWorkerIndex = -1;\n\nclass RLottie {\n  // Config\n\n  private containers = new Map<HTMLDivElement, {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    isLoaded?: boolean;\n    isPaused?: boolean;\n    onLoad?: NoneToVoidFunction;\n  }>();\n\n  private imgSize!: number;\n\n  private msPerFrame = 1000 / 60;\n\n  private reduceFactor = 1;\n\n  private cacheModulo!: number;\n\n  private chunkSize!: number;\n\n  private workerIndex!: number;\n\n  private chunks: Chunks = [];\n\n  private framesCount?: number;\n\n  private chunksCount?: number;\n\n  // State\n\n  private isAnimating = false;\n\n  private isWaiting = true;\n\n  private isEnded = false;\n\n  private isDestroyed = false;\n\n  private isRendererInited = false;\n\n  private approxFrameIndex = 0;\n\n  private prevFrameIndex = -1;\n\n  private stopFrameIndex? = 0;\n\n  private speed = 1;\n\n  private direction: 1 | -1 = 1;\n\n  private lastRenderAt?: number;\n\n  static init(...args: ConstructorParameters<typeof RLottie>) {\n    const [container, onLoad, id] = args;\n    let instance = instancesById.get(id);\n\n    if (!instance) {\n      // eslint-disable-next-line prefer-rest-params\n      instance = new RLottie(...args);\n      instancesById.set(id, instance);\n    } else {\n      instance.addContainer(container, onLoad);\n    }\n\n    return instance;\n  }\n\n  constructor(\n    container: HTMLDivElement,\n    onLoad: NoneToVoidFunction | undefined,\n    private id: string,\n    private tgsUrl: string,\n    private params: Params = {},\n    private customColor?: [number, number, number],\n    private onEnded?: (isDestroyed?: boolean) => void,\n    private onLoop?: () => void,\n  ) {\n    this.addContainer(container, onLoad);\n    this.initConfig();\n    this.initRenderer();\n  }\n\n  public removeContainer(container: HTMLDivElement) {\n    this.containers.get(container)!.canvas.remove();\n    this.containers.delete(container);\n\n    if (!this.containers.size) {\n      this.destroy();\n    }\n  }\n\n  isPlaying() {\n    return this.isAnimating || this.isWaiting;\n  }\n\n  play(forceRestart = false, container?: HTMLDivElement) {\n    if (container) {\n      this.containers.get(container)!.isPaused = false;\n    }\n\n    if (this.isEnded && forceRestart) {\n      this.approxFrameIndex = Math.floor(0);\n    }\n\n    this.stopFrameIndex = undefined;\n    this.direction = 1;\n    this.doPlay();\n  }\n\n  pause(container?: HTMLDivElement) {\n    if (container) {\n      this.containers.get(container)!.isPaused = true;\n\n      const areAllContainersPaused = Array.from(this.containers.values()).every(({ isPaused }) => isPaused);\n      if (!areAllContainersPaused) {\n        return;\n      }\n    }\n\n    if (this.isWaiting) {\n      this.stopFrameIndex = this.approxFrameIndex;\n    } else {\n      this.isAnimating = false;\n    }\n\n    const currentChunkIndex = this.getChunkIndex(this.approxFrameIndex);\n    this.chunks = this.chunks.map((chunk, i) => (i === currentChunkIndex ? chunk : undefined));\n  }\n\n  playSegment([startFrameIndex, stopFrameIndex]: [number, number]) {\n    this.approxFrameIndex = Math.floor(startFrameIndex / this.reduceFactor);\n    this.stopFrameIndex = Math.floor(stopFrameIndex / this.reduceFactor);\n    this.direction = startFrameIndex < stopFrameIndex ? 1 : -1;\n    this.doPlay();\n  }\n\n  setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  setNoLoop(noLoop: boolean) {\n    this.params.noLoop = noLoop;\n  }\n\n  private addContainer(container: HTMLDivElement, onLoad?: NoneToVoidFunction) {\n    if (!(container.parentNode instanceof HTMLElement)) {\n      throw new Error('[RLottie] Container is not mounted');\n    }\n\n    let { size } = this.params;\n\n    if (!size) {\n      size = (\n        container.offsetWidth\n        || parseInt(container.style.width, 10)\n        || container.parentNode.offsetWidth\n      );\n\n      if (!size) {\n        throw new Error('[RLottie] Failed to detect width from container');\n      }\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.dataset.id = this.id;\n    const ctx = canvas.getContext('2d')!;\n\n    canvas.style.width = `${size}px`;\n    canvas.style.height = `${size}px`;\n\n    const { isLowPriority, quality = isLowPriority ? LOW_PRIORITY_QUALITY : HIGH_PRIORITY_QUALITY } = this.params;\n    // Reduced quality only looks acceptable on high DPR screens\n    const imgSize = Math.round(size * Math.max(DPR * quality, 1));\n\n    canvas.width = imgSize;\n    canvas.height = imgSize;\n\n    container.appendChild(canvas);\n\n    if (!this.imgSize) {\n      this.imgSize = imgSize;\n    }\n\n    this.containers.set(container, { canvas, ctx, onLoad });\n\n    if (this.isRendererInited) {\n      this.doPlay();\n    }\n  }\n\n  private destroy() {\n    this.isDestroyed = true;\n    this.pause();\n    this.destroyRenderer();\n\n    instancesById.delete(this.id);\n  }\n\n  private initConfig() {\n    const { isLowPriority } = this.params;\n\n    this.cacheModulo = isLowPriority ? LOW_PRIORITY_CACHE_MODULO : HIGH_PRIORITY_CACHE_MODULO;\n    this.chunkSize = CHUNK_SIZE;\n  }\n\n  setColor(newColor: [number, number, number] | undefined) {\n    this.customColor = newColor;\n  }\n\n  private initRenderer() {\n    this.workerIndex = cycleRestrict(MAX_WORKERS, ++lastWorkerIndex);\n\n    workers[this.workerIndex].request({\n      name: 'init',\n      args: [\n        this.id,\n        this.tgsUrl,\n        this.imgSize,\n        this.params.isLowPriority,\n        this.onRendererInit.bind(this),\n      ],\n    });\n  }\n\n  private destroyRenderer() {\n    workers[this.workerIndex].request({\n      name: 'destroy',\n      args: [this.id],\n    });\n  }\n\n  private onRendererInit(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.isRendererInited = true;\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n    this.chunksCount = Math.ceil(framesCount / this.chunkSize);\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n\n  changeData(tgsUrl: string) {\n    this.pause();\n    this.tgsUrl = tgsUrl;\n    this.initConfig();\n\n    workers[this.workerIndex].request({\n      name: 'changeData',\n      args: [\n        this.id,\n        this.tgsUrl,\n        this.params.isLowPriority,\n        this.onChangeData.bind(this),\n      ],\n    });\n  }\n\n  private onChangeData(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n    this.chunksCount = Math.ceil(framesCount / this.chunkSize);\n    this.isWaiting = false;\n    this.isAnimating = false;\n\n    this.doPlay();\n  }\n\n  private doPlay() {\n    if (!this.framesCount) {\n      return;\n    }\n\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (this.isAnimating) {\n      return;\n    }\n\n    if (!this.isWaiting) {\n      this.lastRenderAt = undefined;\n    }\n\n    this.isEnded = false;\n    this.isAnimating = true;\n    this.isWaiting = false;\n\n    animate(() => {\n      if (this.isDestroyed) {\n        return false;\n      }\n\n      // Paused from outside\n      if (!this.isAnimating) {\n        return false;\n      }\n\n      const frameIndex = Math.round(this.approxFrameIndex);\n      const chunkIndex = this.getChunkIndex(frameIndex);\n      const chunk = this.chunks[chunkIndex];\n\n      if (!chunk || chunk.length === 0) {\n        this.requestChunk(chunkIndex);\n        this.isAnimating = false;\n        this.isWaiting = true;\n        return false;\n      }\n\n      if (this.cacheModulo && chunkIndex % this.cacheModulo === 0) {\n        this.cleanupPrevChunk(chunkIndex);\n      }\n\n      if (frameIndex !== this.prevFrameIndex) {\n        const frame = this.getFrame(frameIndex);\n        if (!frame) {\n          this.isAnimating = false;\n          this.isWaiting = true;\n          return false;\n        }\n\n        const arr = new Uint8ClampedArray(frame);\n        if (this.customColor) {\n          for (let i = 0; i < arr.length; i += 4) {\n            /* eslint-disable prefer-destructuring */\n            arr[i] = this.customColor[0];\n            arr[i + 1] = this.customColor[1];\n            arr[i + 2] = this.customColor[2];\n            /* eslint-enable prefer-destructuring */\n          }\n        }\n        const imageData = new ImageData(arr, this.imgSize, this.imgSize);\n\n        this.containers.forEach((containerData) => {\n          const {\n            ctx, isLoaded, isPaused, onLoad,\n          } = containerData;\n\n          if (!isLoaded || !isPaused) {\n            ctx.putImageData(imageData, 0, 0);\n          }\n\n          if (!isLoaded) {\n            containerData.isLoaded = true;\n            onLoad?.();\n          }\n        });\n\n        this.prevFrameIndex = frameIndex;\n      }\n\n      const now = Date.now();\n      const currentSpeed = this.lastRenderAt ? this.msPerFrame / (now - this.lastRenderAt) : 1;\n      const delta = Math.min(1, (this.direction * this.speed) / currentSpeed);\n      const expectedNextFrameIndex = Math.round(this.approxFrameIndex + delta);\n\n      this.lastRenderAt = now;\n\n      // Forward animation finished\n      if (delta > 0 && (frameIndex === this.framesCount! - 1 || expectedNextFrameIndex > this.framesCount! - 1)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.isEnded = true;\n          this.onEnded?.();\n          return false;\n        }\n        this.onLoop?.();\n\n        this.approxFrameIndex = 0;\n\n        // Backward animation finished\n      } else if (delta < 0 && (frameIndex === 0 || expectedNextFrameIndex < 0)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.isEnded = true;\n          this.onEnded?.();\n          return false;\n        }\n        this.onLoop?.();\n\n        this.approxFrameIndex = this.framesCount! - 1;\n\n        // Stop frame reached\n      } else if (\n        this.stopFrameIndex !== undefined\n        && (frameIndex === this.stopFrameIndex\n          || (\n            (delta > 0 && expectedNextFrameIndex > this.stopFrameIndex)\n            || (delta < 0 && expectedNextFrameIndex < this.stopFrameIndex)\n          ))\n      ) {\n        this.stopFrameIndex = undefined;\n        this.isAnimating = false;\n        return false;\n\n        // Preparing next frame\n      } else {\n        this.approxFrameIndex += delta;\n      }\n\n      const nextFrameIndex = Math.round(this.approxFrameIndex);\n\n      if (!this.getFrame(nextFrameIndex)) {\n        this.requestChunk(this.getChunkIndex(nextFrameIndex));\n        this.isWaiting = true;\n        this.isAnimating = false;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private getFrame(frameIndex: number) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    const indexInChunk = this.getFrameIndexInChunk(frameIndex);\n    const chunk = this.chunks[chunkIndex];\n    if (!chunk) {\n      return undefined;\n    }\n\n    return chunk[indexInChunk];\n  }\n\n  private getFrameIndexInChunk(frameIndex: number) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    return frameIndex - chunkIndex * this.chunkSize;\n  }\n\n  private getChunkIndex(frameIndex: number) {\n    return Math.floor(frameIndex / this.chunkSize);\n  }\n\n  private requestChunk(chunkIndex: number) {\n    if (this.chunks[chunkIndex] && this.chunks[chunkIndex]?.length !== 0) {\n      return;\n    }\n\n    this.chunks[chunkIndex] = [];\n\n    const fromIndex = chunkIndex * this.chunkSize;\n    const toIndex = Math.min(fromIndex + this.chunkSize - 1, this.framesCount! - 1);\n\n    workers[this.workerIndex].request({\n      name: 'renderFrames',\n      args: [this.id, fromIndex, toIndex, this.onFrameLoad.bind(this)],\n    });\n  }\n\n  private cleanupPrevChunk(chunkIndex: number) {\n    if (this.chunksCount! < 3) {\n      return;\n    }\n\n    const prevChunkIndex = cycleRestrict(this.chunksCount!, chunkIndex - 1);\n    this.chunks[prevChunkIndex] = undefined;\n  }\n\n  private requestNextChunk(chunkIndex: number) {\n    if (this.chunksCount === 1) {\n      return;\n    }\n\n    const nextChunkIndex = cycleRestrict(this.chunksCount!, chunkIndex + 1);\n\n    if (!this.chunks[nextChunkIndex]) {\n      this.requestChunk(nextChunkIndex);\n    }\n  }\n\n  private onFrameLoad(frameIndex: number, arrayBuffer: ArrayBuffer) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    const chunk = this.chunks[chunkIndex];\n    // Frame can be skipped and chunk can be already cleaned up\n    if (!chunk) {\n      return;\n    }\n\n    chunk[this.getFrameIndexInChunk(frameIndex)] = arrayBuffer;\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n}\n\nexport default RLottie;\n","export default function cycleRestrict(length: number, index: number) {\n  return index - Math.floor(index / length) * length;\n}\n"],"names":["WorkerConnector","constructor","worker","Map","this","subscribe","request","messageData","requestStates","requestStatesByCallback","messageId","generateIdFor","payload","type","requestState","promise","Promise","resolve","reject","Object","assign","args","length","withCallback","callback","pop","set","catch","finally","delete","postMessage","cancelCallback","progressCallback","isCanceled","get","addEventListener","data","error","response","callbackArgs","Error","message","HIGH_PRIORITY_QUALITY","IS_SINGLE_COLUMN_LAYOUT","LOW_PRIORITY_QUALITY","IS_ANDROID","HIGH_PRIORITY_CACHE_MODULO","IS_SAFARI","instancesById","workers","Array","fill","undefined","map","Worker","URL","lastWorkerIndex","RLottie","container","onLoad","id","instance","addContainer","tgsUrl","params","customColor","onEnded","onLoop","initConfig","initRenderer","removeContainer","containers","canvas","remove","size","destroy","isPlaying","isAnimating","isWaiting","play","forceRestart","isPaused","isEnded","approxFrameIndex","Math","floor","stopFrameIndex","direction","doPlay","pause","from","values","every","currentChunkIndex","getChunkIndex","chunks","chunk","i","playSegment","startFrameIndex","reduceFactor","setSpeed","speed","setNoLoop","noLoop","parentNode","HTMLElement","offsetWidth","parseInt","style","width","document","createElement","dataset","ctx","getContext","height","isLowPriority","quality","imgSize","round","max","DPR","appendChild","isRendererInited","isDestroyed","destroyRenderer","cacheModulo","chunkSize","setColor","newColor","workerIndex","cycleRestrict","name","onRendererInit","bind","msPerFrame","framesCount","chunksCount","ceil","changeData","onChangeData","lastRenderAt","animate","frameIndex","chunkIndex","requestChunk","cleanupPrevChunk","prevFrameIndex","frame","getFrame","arr","Uint8ClampedArray","imageData","ImageData","forEach","containerData","isLoaded","putImageData","now","Date","currentSpeed","delta","min","expectedNextFrameIndex","nextFrameIndex","indexInChunk","getFrameIndexInChunk","fromIndex","toIndex","onFrameLoad","prevChunkIndex","requestNextChunk","nextChunkIndex","arrayBuffer","index"],"sourceRoot":""}