{"version":3,"file":"7941.ae7dedc7950318e16ad9.js","mappings":"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","sources":["webpack://telegram-t/./src/util/WorkerConnector.ts","webpack://telegram-t/./src/lib/rlottie/RLottie.ts","webpack://telegram-t/./src/util/cycleRestrict.ts"],"sourcesContent":["import generateIdFor from './generateIdFor';\n\nexport interface CancellableCallback {\n  (\n    ...args: any[]\n  ): void;\n\n  isCanceled?: boolean;\n  acceptsBuffer?: boolean;\n}\n\ntype CallMethodData = {\n  type: 'callMethod';\n  messageId?: string;\n  name: string;\n  args: any;\n  withCallback?: boolean;\n};\n\ntype OriginMessageData = CallMethodData | {\n  type: 'cancelProgress';\n  messageId: string;\n};\n\nexport interface OriginMessageEvent {\n  data: OriginMessageData;\n}\n\nexport type WorkerMessageData = {\n  type: 'methodResponse';\n  messageId: string;\n  response?: any;\n  error?: { message: string };\n} | {\n  type: 'methodCallback';\n  messageId: string;\n  callbackArgs: any[];\n} | {\n  type: 'unhandledError';\n  error?: { message: string };\n};\n\nexport interface WorkerMessageEvent {\n  data: WorkerMessageData;\n}\n\ninterface RequestStates {\n  messageId: string;\n  resolve: Function;\n  reject: Function;\n  callback: AnyToVoidFunction;\n}\n\n// TODO Replace `any` with proper generics\nexport default class WorkerConnector {\n  private requestStates = new Map<string, RequestStates>();\n\n  private requestStatesByCallback = new Map<AnyToVoidFunction, RequestStates>();\n\n  constructor(private worker: Worker) {\n    this.subscribe();\n  }\n\n  request(messageData: { name: string; args: any }) {\n    const { worker, requestStates, requestStatesByCallback } = this;\n\n    const messageId = generateIdFor(requestStates);\n    const payload: CallMethodData = {\n      type: 'callMethod',\n      messageId,\n      ...messageData,\n    };\n\n    const requestState = { messageId } as RequestStates;\n\n    // Re-wrap type because of `postMessage`\n    const promise: Promise<any> = new Promise((resolve, reject) => {\n      Object.assign(requestState, { resolve, reject });\n    });\n\n    if (typeof payload.args[payload.args.length - 1] === 'function') {\n      payload.withCallback = true;\n\n      const callback = payload.args.pop() as AnyToVoidFunction;\n      requestState.callback = callback;\n      requestStatesByCallback.set(callback, requestState);\n    }\n\n    requestStates.set(messageId, requestState);\n    promise\n      .catch(() => undefined)\n      .finally(() => {\n        requestStates.delete(messageId);\n\n        if (requestState.callback) {\n          requestStatesByCallback.delete(requestState.callback);\n        }\n      });\n\n    worker.postMessage(payload);\n\n    return promise;\n  }\n\n  cancelCallback(progressCallback: CancellableCallback) {\n    progressCallback.isCanceled = true;\n\n    const { messageId } = this.requestStatesByCallback.get(progressCallback) || {};\n    if (!messageId) {\n      return;\n    }\n\n    this.worker.postMessage({\n      type: 'cancelProgress',\n      messageId,\n    });\n  }\n\n  private subscribe() {\n    const { worker, requestStates } = this;\n\n    worker.addEventListener('message', ({ data }: WorkerMessageEvent) => {\n      if (data.type === 'methodResponse') {\n        const requestState = requestStates.get(data.messageId);\n        if (requestState) {\n          if (data.error) {\n            requestState.reject(data.error);\n          } else {\n            requestState.resolve(data.response);\n          }\n        }\n      } else if (data.type === 'methodCallback') {\n        const requestState = requestStates.get(data.messageId);\n        requestState?.callback?.(...data.callbackArgs);\n      } else if (data.type === 'unhandledError') {\n        throw new Error(data.error?.message);\n      }\n    });\n  }\n}\n","import {\n  DPR,\n  IS_SINGLE_COLUMN_LAYOUT,\n  IS_SAFARI,\n  IS_ANDROID,\n} from '../../util/environment';\nimport WorkerConnector from '../../util/WorkerConnector';\nimport { animate } from '../../util/animation';\nimport cycleRestrict from '../../util/cycleRestrict';\nimport { fastRaf } from '../../util/schedulers';\n\ninterface Params {\n  noLoop?: boolean;\n  size?: number;\n  quality?: number;\n  isLowPriority?: boolean;\n  coords?: { x: number; y: number };\n}\n\nconst WAITING = Symbol('WAITING');\ntype Frame =\n  undefined\n  | typeof WAITING\n  | ImageBitmap;\n\nconst MAX_WORKERS = 4;\nconst HIGH_PRIORITY_QUALITY = IS_SINGLE_COLUMN_LAYOUT ? 0.75 : 1;\nconst LOW_PRIORITY_QUALITY = IS_ANDROID ? 0.5 : 0.75;\nconst LOW_PRIORITY_QUALITY_SIZE_THRESHOLD = 24;\nconst HIGH_PRIORITY_CACHE_MODULO = IS_SAFARI ? 2 : 4;\nconst LOW_PRIORITY_CACHE_MODULO = 0;\n\nconst instancesById = new Map<string, RLottie>();\n\nconst workers = new Array(MAX_WORKERS).fill(undefined).map(\n  () => new WorkerConnector(new Worker(new URL('./rlottie.worker.ts', import.meta.url))),\n);\nlet lastWorkerIndex = -1;\n\nclass RLottie {\n  // Config\n\n  private containers = new Map<string, {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    isLoaded?: boolean;\n    isPaused?: boolean;\n    isSharedCanvas?: boolean;\n    coords?: Params['coords'];\n    onLoad?: NoneToVoidFunction;\n  }>();\n\n  private imgSize!: number;\n\n  private imageData!: ImageData;\n\n  private msPerFrame = 1000 / 60;\n\n  private reduceFactor = 1;\n\n  private cacheModulo!: number;\n\n  private workerIndex!: number;\n\n  private frames: Frame[] = [];\n\n  private framesCount?: number;\n\n  // State\n\n  private isAnimating = false;\n\n  private isWaiting = true;\n\n  private isEnded = false;\n\n  private isDestroyed = false;\n\n  private isRendererInited = false;\n\n  private approxFrameIndex = 0;\n\n  private prevFrameIndex = -1;\n\n  private stopFrameIndex? = 0;\n\n  private speed = 1;\n\n  private direction: 1 | -1 = 1;\n\n  private lastRenderAt?: number;\n\n  static init(...args: ConstructorParameters<typeof RLottie>) {\n    const [container, canvas, onLoad, id, , params] = args;\n    let instance = instancesById.get(id);\n\n    if (!instance) {\n      // eslint-disable-next-line prefer-rest-params\n      instance = new RLottie(...args);\n      instancesById.set(id, instance);\n    } else {\n      instance.addContainer(container, canvas, onLoad, params?.coords);\n    }\n\n    return instance;\n  }\n\n  constructor(\n    containerId: string,\n    container: HTMLDivElement | HTMLCanvasElement,\n    onLoad: NoneToVoidFunction | undefined,\n    private id: string,\n    private tgsUrl: string,\n    private params: Params = {},\n    private customColor?: [number, number, number],\n    private onEnded?: (isDestroyed?: boolean) => void,\n    private onLoop?: () => void,\n  ) {\n    this.addContainer(containerId, container, onLoad, params.coords);\n    this.initConfig();\n    this.initRenderer();\n  }\n\n  public removeContainer(containerId: string) {\n    const {\n      canvas, ctx, isSharedCanvas, coords,\n    } = this.containers.get(containerId)!;\n\n    if (isSharedCanvas) {\n      ctx.clearRect(coords!.x, coords!.y, this.imgSize, this.imgSize);\n    } else {\n      canvas.remove();\n    }\n\n    this.containers.delete(containerId);\n\n    if (!this.containers.size) {\n      this.destroy();\n    }\n  }\n\n  isPlaying() {\n    return this.isAnimating || this.isWaiting;\n  }\n\n  play(forceRestart = false, containerId?: string) {\n    if (containerId) {\n      this.containers.get(containerId)!.isPaused = false;\n    }\n\n    if (this.isEnded && forceRestart) {\n      this.approxFrameIndex = Math.floor(0);\n    }\n\n    this.stopFrameIndex = undefined;\n    this.direction = 1;\n    this.doPlay();\n  }\n\n  pause(containerId?: string) {\n    if (containerId) {\n      this.containers.get(containerId)!.isPaused = true;\n\n      const areAllContainersPaused = Array.from(this.containers.values()).every(({ isPaused }) => isPaused);\n      if (!areAllContainersPaused) {\n        return;\n      }\n    }\n\n    if (this.isWaiting) {\n      this.stopFrameIndex = this.approxFrameIndex;\n    } else {\n      this.isAnimating = false;\n    }\n\n    if (!this.params.isLowPriority) {\n      this.frames = this.frames.map((frame, i) => {\n        if (i === this.prevFrameIndex) {\n          return frame;\n        } else {\n          if (frame && frame !== WAITING) {\n            frame.close();\n          }\n\n          return undefined;\n        }\n      });\n    }\n  }\n\n  playSegment([startFrameIndex, stopFrameIndex]: [number, number]) {\n    this.approxFrameIndex = Math.floor(startFrameIndex / this.reduceFactor);\n    this.stopFrameIndex = Math.floor(stopFrameIndex / this.reduceFactor);\n    this.direction = startFrameIndex < stopFrameIndex ? 1 : -1;\n    this.doPlay();\n  }\n\n  setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  setNoLoop(noLoop?: boolean) {\n    this.params.noLoop = noLoop;\n  }\n\n  setSharedCanvasCoords(containerId: string, newCoords: Params['coords']) {\n    const containerInfo = this.containers.get(containerId)!;\n    const {\n      canvas, ctx, isPaused, coords,\n    } = containerInfo;\n\n    if (!canvas.dataset.isJustCleaned || canvas.dataset.isJustCleaned === 'false') {\n      const sizeFactor = this.calcSizeFactor();\n      ensureCanvasSize(canvas, sizeFactor);\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      canvas.dataset.isJustCleaned = 'true';\n      fastRaf(() => {\n        canvas.dataset.isJustCleaned = 'false';\n      });\n    }\n\n    containerInfo.coords = {\n      x: Math.round((newCoords?.x || 0) * canvas.width),\n      y: Math.round((newCoords?.y || 0) * canvas.height),\n    };\n\n    if (isPaused || !this.isPlaying()) {\n      const frame = this.getFrame(this.prevFrameIndex) || this.getFrame(Math.round(this.approxFrameIndex));\n\n      if (frame && frame !== WAITING) {\n        ctx.drawImage(frame, coords!.x, coords!.y);\n      }\n    }\n  }\n\n  private addContainer(\n    containerId: string,\n    container: HTMLDivElement | HTMLCanvasElement,\n    onLoad?: NoneToVoidFunction,\n    coords?: Params['coords'],\n  ) {\n    const sizeFactor = this.calcSizeFactor();\n\n    let imgSize: number;\n\n    if (container instanceof HTMLDivElement) {\n      if (!(container.parentNode instanceof HTMLElement)) {\n        throw new Error('[RLottie] Container is not mounted');\n      }\n\n      let { size } = this.params;\n\n      if (!size) {\n        size = (\n          container.offsetWidth\n          || parseInt(container.style.width, 10)\n          || container.parentNode.offsetWidth\n        );\n\n        if (!size) {\n          throw new Error('[RLottie] Failed to detect width from container');\n        }\n      }\n\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d')!;\n\n      canvas.style.width = `${size}px`;\n      canvas.style.height = `${size}px`;\n\n      imgSize = Math.round(size * sizeFactor);\n\n      canvas.width = imgSize;\n      canvas.height = imgSize;\n\n      container.appendChild(canvas);\n\n      this.containers.set(containerId, {\n        canvas, ctx, onLoad,\n      });\n    } else {\n      if (!container.offsetParent) {\n        throw new Error('[RLottie] Shared canvas is not mounted');\n      }\n\n      const canvas = container;\n      const ctx = canvas.getContext('2d')!;\n\n      ensureCanvasSize(canvas, sizeFactor);\n\n      imgSize = Math.round(this.params.size! * sizeFactor);\n\n      this.containers.set(containerId, {\n        canvas,\n        ctx,\n        isSharedCanvas: true,\n        coords: {\n          x: Math.round((coords?.x || 0) * canvas.width),\n          y: Math.round((coords?.y || 0) * canvas.height),\n        },\n        onLoad,\n      });\n    }\n\n    if (!this.imgSize) {\n      this.imgSize = imgSize;\n      this.imageData = new ImageData(imgSize, imgSize);\n    }\n\n    if (this.isRendererInited) {\n      this.doPlay();\n    }\n  }\n\n  private calcSizeFactor() {\n    const {\n      isLowPriority,\n      size,\n      // Reduced quality only looks acceptable on big enough images\n      quality = isLowPriority && (!size || size > LOW_PRIORITY_QUALITY_SIZE_THRESHOLD)\n        ? LOW_PRIORITY_QUALITY\n        : HIGH_PRIORITY_QUALITY,\n    } = this.params;\n\n    // Reduced quality only looks acceptable on high DPR screens\n    return Math.max(DPR * quality, 1);\n  }\n\n  private destroy() {\n    this.isDestroyed = true;\n    this.pause();\n    this.clearCache();\n    this.destroyRenderer();\n\n    instancesById.delete(this.id);\n  }\n\n  private clearCache() {\n    this.frames.forEach((frame) => {\n      if (frame && frame !== WAITING) {\n        frame.close();\n      }\n    });\n\n    // Help GC\n    this.imageData = undefined as any;\n    this.frames = [];\n  }\n\n  private initConfig() {\n    const { isLowPriority } = this.params;\n\n    this.cacheModulo = isLowPriority ? LOW_PRIORITY_CACHE_MODULO : HIGH_PRIORITY_CACHE_MODULO;\n  }\n\n  setColor(newColor: [number, number, number] | undefined) {\n    this.customColor = newColor;\n  }\n\n  private initRenderer() {\n    this.workerIndex = cycleRestrict(MAX_WORKERS, ++lastWorkerIndex);\n\n    workers[this.workerIndex].request({\n      name: 'init',\n      args: [\n        this.id,\n        this.tgsUrl,\n        this.imgSize,\n        this.params.isLowPriority,\n        this.customColor,\n        this.onRendererInit.bind(this),\n      ],\n    });\n  }\n\n  private destroyRenderer() {\n    workers[this.workerIndex].request({\n      name: 'destroy',\n      args: [this.id],\n    });\n  }\n\n  private onRendererInit(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.isRendererInited = true;\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n\n  changeData(tgsUrl: string) {\n    this.pause();\n    this.tgsUrl = tgsUrl;\n    this.initConfig();\n\n    workers[this.workerIndex].request({\n      name: 'changeData',\n      args: [\n        this.id,\n        this.tgsUrl,\n        this.params.isLowPriority,\n        this.onChangeData.bind(this),\n      ],\n    });\n  }\n\n  private onChangeData(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n    this.isWaiting = false;\n    this.isAnimating = false;\n\n    this.doPlay();\n  }\n\n  private doPlay() {\n    if (!this.framesCount) {\n      return;\n    }\n\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (this.isAnimating) {\n      return;\n    }\n\n    if (!this.isWaiting) {\n      this.lastRenderAt = undefined;\n    }\n\n    this.isEnded = false;\n    this.isAnimating = true;\n    this.isWaiting = false;\n\n    animate(() => {\n      if (this.isDestroyed) {\n        return false;\n      }\n\n      // Paused from outside\n      if (!this.isAnimating) {\n        return false;\n      }\n\n      const frameIndex = Math.round(this.approxFrameIndex);\n      const frame = this.getFrame(frameIndex);\n      if (!frame || frame === WAITING) {\n        if (!frame) {\n          this.requestFrame(frameIndex);\n        }\n\n        this.isAnimating = false;\n        this.isWaiting = true;\n        return false;\n      }\n\n      if (this.cacheModulo && frameIndex % this.cacheModulo === 0) {\n        this.cleanupPrevFrame(frameIndex);\n      }\n\n      if (frameIndex !== this.prevFrameIndex) {\n        this.containers.forEach((containerData) => {\n          const {\n            ctx, isLoaded, isPaused, coords: { x, y } = {}, onLoad,\n          } = containerData;\n\n          if (!isLoaded || !isPaused) {\n            ctx.clearRect(x || 0, y || 0, this.imgSize, this.imgSize);\n            ctx.drawImage(frame, x || 0, y || 0);\n          }\n\n          if (!isLoaded) {\n            containerData.isLoaded = true;\n            onLoad?.();\n          }\n        });\n\n        this.prevFrameIndex = frameIndex;\n      }\n\n      const now = Date.now();\n      const currentSpeed = this.lastRenderAt ? this.msPerFrame / (now - this.lastRenderAt) : 1;\n      const delta = Math.min(1, (this.direction * this.speed) / currentSpeed);\n      const expectedNextFrameIndex = Math.round(this.approxFrameIndex + delta);\n\n      this.lastRenderAt = now;\n\n      // Forward animation finished\n      if (delta > 0 && (frameIndex === this.framesCount! - 1 || expectedNextFrameIndex > this.framesCount! - 1)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.isEnded = true;\n          this.onEnded?.();\n          return false;\n        }\n        this.onLoop?.();\n\n        this.approxFrameIndex = 0;\n\n        // Backward animation finished\n      } else if (delta < 0 && (frameIndex === 0 || expectedNextFrameIndex < 0)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.isEnded = true;\n          this.onEnded?.();\n          return false;\n        }\n        this.onLoop?.();\n\n        this.approxFrameIndex = this.framesCount! - 1;\n\n        // Stop frame reached\n      } else if (\n        this.stopFrameIndex !== undefined\n        && (frameIndex === this.stopFrameIndex\n          || (\n            (delta > 0 && expectedNextFrameIndex > this.stopFrameIndex)\n            || (delta < 0 && expectedNextFrameIndex < this.stopFrameIndex)\n          ))\n      ) {\n        this.stopFrameIndex = undefined;\n        this.isAnimating = false;\n        return false;\n\n        // Preparing next frame\n      } else {\n        this.approxFrameIndex += delta;\n      }\n\n      const nextFrameIndex = Math.round(this.approxFrameIndex);\n\n      if (!this.getFrame(nextFrameIndex)) {\n        this.requestFrame(nextFrameIndex);\n        this.isWaiting = true;\n        this.isAnimating = false;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private getFrame(frameIndex: number) {\n    return this.frames[frameIndex];\n  }\n\n  private requestFrame(frameIndex: number) {\n    this.frames[frameIndex] = WAITING;\n\n    workers[this.workerIndex].request({\n      name: 'renderFrames',\n      args: [this.id, frameIndex, this.onFrameLoad.bind(this)],\n    });\n  }\n\n  private cleanupPrevFrame(frameIndex: number) {\n    if (this.framesCount! < 3) {\n      return;\n    }\n\n    const prevFrameIndex = cycleRestrict(this.framesCount!, frameIndex - 1);\n    this.frames[prevFrameIndex] = undefined;\n  }\n\n  private onFrameLoad(frameIndex: number, imageBitmap: ImageBitmap) {\n    if (this.frames[frameIndex] !== WAITING) {\n      return;\n    }\n\n    this.frames[frameIndex] = imageBitmap;\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n}\n\nfunction ensureCanvasSize(canvas: HTMLCanvasElement, sizeFactor: number) {\n  const expectedWidth = Math.round(canvas.offsetWidth * sizeFactor);\n  const expectedHeight = Math.round(canvas.offsetHeight * sizeFactor);\n  if (canvas.width !== expectedWidth || canvas.height !== expectedHeight) {\n    canvas.width = expectedWidth;\n    canvas.height = expectedHeight;\n  }\n}\n\nexport default RLottie;\n","export default function cycleRestrict(length: number, index: number) {\n  return index - Math.floor(index / length) * length;\n}\n"],"names":["WorkerConnector","constructor","worker","Map","this","subscribe","request","messageData","requestStates","requestStatesByCallback","messageId","generateIdFor","payload","type","requestState","promise","Promise","resolve","reject","Object","assign","args","length","withCallback","callback","pop","set","catch","finally","delete","postMessage","cancelCallback","progressCallback","isCanceled","get","addEventListener","data","error","response","callbackArgs","Error","message","WAITING","Symbol","HIGH_PRIORITY_QUALITY","IS_SINGLE_COLUMN_LAYOUT","LOW_PRIORITY_QUALITY","IS_ANDROID","LOW_PRIORITY_QUALITY_SIZE_THRESHOLD","HIGH_PRIORITY_CACHE_MODULO","IS_SAFARI","instancesById","workers","Array","fill","undefined","map","Worker","URL","lastWorkerIndex","RLottie","container","canvas","onLoad","id","params","instance","addContainer","coords","containerId","tgsUrl","customColor","onEnded","onLoop","initConfig","initRenderer","removeContainer","ctx","isSharedCanvas","containers","clearRect","x","y","imgSize","remove","size","destroy","isPlaying","isAnimating","isWaiting","play","forceRestart","isPaused","isEnded","approxFrameIndex","Math","floor","stopFrameIndex","direction","doPlay","pause","from","values","every","isLowPriority","frames","frame","i","prevFrameIndex","close","playSegment","startFrameIndex","reduceFactor","setSpeed","speed","setNoLoop","noLoop","setSharedCanvasCoords","newCoords","containerInfo","dataset","isJustCleaned","sizeFactor","calcSizeFactor","ensureCanvasSize","width","height","fastRaf","round","getFrame","drawImage","HTMLDivElement","parentNode","HTMLElement","offsetWidth","parseInt","style","document","createElement","getContext","appendChild","offsetParent","imageData","ImageData","isRendererInited","quality","max","DPR","isDestroyed","clearCache","destroyRenderer","forEach","cacheModulo","setColor","newColor","workerIndex","cycleRestrict","name","onRendererInit","bind","msPerFrame","framesCount","changeData","onChangeData","lastRenderAt","animate","frameIndex","requestFrame","cleanupPrevFrame","containerData","isLoaded","now","Date","currentSpeed","delta","min","expectedNextFrameIndex","nextFrameIndex","onFrameLoad","imageBitmap","expectedWidth","expectedHeight","offsetHeight","index"],"sourceRoot":""}