{"version":3,"file":"86.6d6cf073cdc5caf7a069.js","mappings":"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","sources":["webpack://telegram-t/./src/components/common/AnimatedSticker.tsx","webpack://telegram-t/./src/components/common/Avatar.tsx","webpack://telegram-t/./src/components/common/helpers/animatedAssets.ts","webpack://telegram-t/./src/components/ui/ConfirmDialog.tsx","webpack://telegram-t/./src/components/ui/InfiniteScroll.tsx","webpack://telegram-t/./src/components/ui/Modal.tsx","webpack://telegram-t/./src/util/trapFocus.ts","webpack://telegram-t/./src/components/ui/Portal.ts","webpack://telegram-t/./src/hooks/useBackgroundMode.ts","webpack://telegram-t/./src/hooks/useCurrentOrPrev.ts","webpack://telegram-t/./src/hooks/useInfiniteScroll.ts","webpack://telegram-t/./src/hooks/useMedia.ts","webpack://telegram-t/./src/util/clipboard.ts","webpack://telegram-t/./src/util/folderManager.ts","webpack://telegram-t/./src/util/forceReflow.ts","webpack://telegram-t/./src/util/resetScroll.ts","webpack://telegram-t/./src/util/safePlay.ts"],"sourcesContent":["import React, {\n  FC, useEffect, useRef, memo, useCallback, useState,\n} from '../../lib/teact/teact';\n\nimport { fastRaf } from '../../util/schedulers';\nimport buildClassName from '../../util/buildClassName';\nimport useHeavyAnimationCheck from '../../hooks/useHeavyAnimationCheck';\nimport useBackgroundMode from '../../hooks/useBackgroundMode';\n\ntype OwnProps = {\n  className?: string;\n  id: string;\n  animationData?: string;\n  play?: boolean | string;\n  playSegment?: [number, number];\n  speed?: number;\n  noLoop?: boolean;\n  size: number;\n  quality?: number;\n  isLowPriority?: boolean;\n  onLoad?: NoneToVoidFunction;\n  forceOnHeavyAnimation?: boolean;\n  color?: [number, number, number];\n  onEnded?: NoneToVoidFunction;\n};\n\ntype RLottieClass = typeof import('../../lib/rlottie/RLottie').default;\ntype RLottieInstance = import('../../lib/rlottie/RLottie').default;\nlet lottiePromise: Promise<RLottieClass>;\nlet RLottie: RLottieClass;\n\n// Time supposed for judges to measure \"Transferred Size\" in Dev Tools\nconst LOTTIE_LOAD_DELAY = 5000;\n\nasync function ensureLottie() {\n  if (!lottiePromise) {\n    lottiePromise = import('../../lib/rlottie/RLottie') as unknown as Promise<RLottieClass>;\n    RLottie = (await lottiePromise as any).default;\n  }\n\n  return lottiePromise;\n}\n\nsetTimeout(ensureLottie, LOTTIE_LOAD_DELAY);\n\nconst AnimatedSticker: FC<OwnProps> = ({\n  className,\n  id,\n  animationData,\n  play,\n  playSegment,\n  speed,\n  noLoop,\n  size,\n  quality,\n  isLowPriority,\n  color,\n  forceOnHeavyAnimation,\n  onLoad,\n  onEnded,\n}) => {\n  const [animation, setAnimation] = useState<RLottieInstance>();\n  // eslint-disable-next-line no-null/no-null\n  const container = useRef<HTMLDivElement>(null);\n  const wasPlaying = useRef(false);\n  const isFrozen = useRef(false);\n  const isFirstRender = useRef(true);\n\n  const playRef = useRef();\n  playRef.current = play;\n  const playSegmentRef = useRef<[number, number]>();\n  playSegmentRef.current = playSegment;\n\n  useEffect(() => {\n    if (animation || !animationData) {\n      return;\n    }\n\n    const exec = () => {\n      if (!container.current) {\n        return;\n      }\n\n      const newAnimation = new RLottie(\n        id,\n        container.current,\n        animationData,\n        {\n          noLoop,\n          size,\n          quality,\n          isLowPriority,\n        },\n        onLoad,\n        color,\n        onEnded,\n      );\n\n      if (speed) {\n        newAnimation.setSpeed(speed);\n      }\n\n      setAnimation(newAnimation);\n    };\n\n    if (RLottie) {\n      exec();\n    } else {\n      ensureLottie().then(() => {\n        fastRaf(() => {\n          if (container.current) {\n            exec();\n          }\n        });\n      });\n    }\n  }, [color, animation, animationData, id, isLowPriority, noLoop, onLoad, quality, size, speed, onEnded]);\n\n  useEffect(() => {\n    if (!animation) return;\n\n    animation.setColor(color);\n  }, [color, animation]);\n\n  useEffect(() => {\n    return () => {\n      if (animation) {\n        animation.destroy();\n      }\n    };\n  }, [animation]);\n\n  const playAnimation = useCallback((shouldRestart = false) => {\n    if (animation && (playRef.current || playSegmentRef.current)) {\n      if (playSegmentRef.current) {\n        animation.playSegment(playSegmentRef.current);\n      } else if (shouldRestart) {\n        animation.goToAndPlay(0);\n      } else {\n        animation.play();\n      }\n    }\n  }, [animation]);\n\n  const pauseAnimation = useCallback(() => {\n    if (!animation) {\n      return;\n    }\n\n    animation.pause();\n  }, [animation]);\n\n  const freezeAnimation = useCallback(() => {\n    isFrozen.current = true;\n\n    if (!animation) {\n      return;\n    }\n\n    if (!wasPlaying.current) {\n      wasPlaying.current = animation.isPlaying();\n    }\n\n    pauseAnimation();\n  }, [animation, pauseAnimation]);\n\n  const unfreezeAnimation = useCallback(() => {\n    if (wasPlaying.current) {\n      playAnimation();\n    }\n\n    wasPlaying.current = false;\n    isFrozen.current = false;\n  }, [playAnimation]);\n\n  const unfreezeAnimationOnRaf = useCallback(() => {\n    fastRaf(unfreezeAnimation);\n  }, [unfreezeAnimation]);\n\n  useEffect(() => {\n    if (!animation) {\n      return;\n    }\n\n    if (play || playSegment) {\n      if (isFrozen.current) {\n        wasPlaying.current = true;\n      } else {\n        playAnimation(noLoop);\n      }\n    } else {\n      // eslint-disable-next-line no-lonely-if\n      if (isFrozen.current) {\n        wasPlaying.current = false;\n      } else {\n        pauseAnimation();\n      }\n    }\n  }, [animation, play, playSegment, noLoop, playAnimation, pauseAnimation]);\n\n  useEffect(() => {\n    if (animation) {\n      if (isFirstRender.current) {\n        isFirstRender.current = false;\n      } else if (animationData) {\n        animation.changeData(animationData);\n        playAnimation();\n      }\n    }\n  }, [playAnimation, animation, animationData]);\n\n  useHeavyAnimationCheck(freezeAnimation, unfreezeAnimation, forceOnHeavyAnimation);\n  // Pausing frame may not happen in background\n  // so we need to make sure it happens right after focusing,\n  // then we can play again.\n  useBackgroundMode(freezeAnimation, unfreezeAnimationOnRaf);\n\n  const fullClassName = buildClassName('AnimatedSticker', className);\n\n  const style = size ? `width: ${size}px; height: ${size}px;` : undefined;\n\n  return (\n    <div\n      ref={container}\n      className={fullClassName}\n      // @ts-ignore\n      style={style}\n    />\n  );\n};\n\nexport default memo(AnimatedSticker);\n","import { MouseEvent as ReactMouseEvent } from 'react';\nimport React, { FC, memo, useCallback } from '../../lib/teact/teact';\n\nimport {\n  ApiChat, ApiMediaFormat, ApiPhoto, ApiUser, ApiUserStatus,\n} from '../../api/types';\n\nimport { IS_TEST } from '../../config';\nimport {\n  getChatAvatarHash,\n  getChatTitle,\n  getUserColorKey,\n  getUserFullName,\n  isUserId,\n  isChatWithRepliesBot,\n  isDeletedUser,\n  isUserOnline,\n} from '../../modules/helpers';\nimport { getFirstLetters } from '../../util/textFormat';\nimport buildClassName from '../../util/buildClassName';\nimport renderText from './helpers/renderText';\nimport useMedia from '../../hooks/useMedia';\nimport useShowTransition from '../../hooks/useShowTransition';\nimport useLang from '../../hooks/useLang';\n\nimport './Avatar.scss';\n\ntype OwnProps = {\n  className?: string;\n  size?: 'micro' | 'tiny' | 'small' | 'medium' | 'large' | 'jumbo';\n  chat?: ApiChat;\n  user?: ApiUser;\n  photo?: ApiPhoto;\n  userStatus?: ApiUserStatus;\n  text?: string;\n  isSavedMessages?: boolean;\n  lastSyncTime?: number;\n  onClick?: (e: ReactMouseEvent<HTMLDivElement, MouseEvent>, hasPhoto: boolean) => void;\n};\n\nconst Avatar: FC<OwnProps> = ({\n  className,\n  size = 'large',\n  chat,\n  user,\n  photo,\n  userStatus,\n  text,\n  isSavedMessages,\n  lastSyncTime,\n  onClick,\n}) => {\n  const isDeleted = user && isDeletedUser(user);\n  const isReplies = user && isChatWithRepliesBot(user.id);\n  let imageHash: string | undefined;\n\n  if (!isSavedMessages && !isDeleted) {\n    if (user) {\n      imageHash = getChatAvatarHash(user);\n    } else if (chat) {\n      imageHash = getChatAvatarHash(chat);\n    } else if (photo) {\n      imageHash = `photo${photo.id}?size=m`;\n    }\n  }\n\n  const blobUrl = useMedia(imageHash, false, ApiMediaFormat.BlobUrl, lastSyncTime);\n  const hasBlobUrl = Boolean(blobUrl);\n  const { transitionClassNames } = useShowTransition(hasBlobUrl, undefined, hasBlobUrl, 'slow');\n\n  const lang = useLang();\n\n  let content: string | undefined = '';\n\n  if (isSavedMessages) {\n    content = <i className=\"icon-avatar-saved-messages\" />;\n  } else if (isDeleted) {\n    content = <i className=\"icon-avatar-deleted-account\" />;\n  } else if (isReplies) {\n    content = <i className=\"icon-reply-filled\" />;\n  } else if (blobUrl) {\n    content = (\n      <img src={blobUrl} className={buildClassName('avatar-media', transitionClassNames)} alt=\"\" decoding=\"async\" />\n    );\n  } else if (user) {\n    const userFullName = getUserFullName(user);\n    content = userFullName ? getFirstLetters(userFullName, 2) : undefined;\n  } else if (chat) {\n    const title = getChatTitle(lang, chat);\n    content = title && getFirstLetters(title, isUserId(chat.id) ? 2 : 1);\n  } else if (text) {\n    content = getFirstLetters(text, 2);\n  }\n\n  const isOnline = !isSavedMessages && user && userStatus && isUserOnline(user, userStatus);\n  const fullClassName = buildClassName(\n    `Avatar size-${size}`,\n    className,\n    `color-bg-${getUserColorKey(user || chat)}`,\n    isSavedMessages && 'saved-messages',\n    isDeleted && 'deleted-account',\n    isReplies && 'replies-bot-account',\n    isOnline && 'online',\n    onClick && 'interactive',\n    (!isSavedMessages && !blobUrl) && 'no-photo',\n  );\n\n  const hasImage = Boolean(isSavedMessages || blobUrl);\n  const handleClick = useCallback((e: ReactMouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (onClick) {\n      onClick(e, hasImage);\n    }\n  }, [onClick, hasImage]);\n\n  const senderId = (user || chat) && (user || chat)!.id;\n\n  return (\n    <div className={fullClassName} onClick={handleClick} data-test-sender-id={IS_TEST ? senderId : undefined}>\n      {typeof content === 'string' ? renderText(content, [size === 'jumbo' ? 'hq_emoji' : 'emoji']) : content}\n    </div>\n  );\n};\n\nexport default memo(Avatar);\n","import { ApiMediaFormat } from '../../../api/types';\n\nimport * as mediaLoader from '../../../util/mediaLoader';\n\nimport MonkeyIdle from '../../../assets/tgs/monkeys/TwoFactorSetupMonkeyIdle.tgs';\nimport MonkeyTracking from '../../../assets/tgs/monkeys/TwoFactorSetupMonkeyTracking.tgs';\nimport MonkeyClose from '../../../assets/tgs/monkeys/TwoFactorSetupMonkeyClose.tgs';\nimport MonkeyPeek from '../../../assets/tgs/monkeys/TwoFactorSetupMonkeyPeek.tgs';\n\nimport FoldersAll from '../../../assets/tgs/settings/FoldersAll.tgs';\nimport FoldersNew from '../../../assets/tgs/settings/FoldersNew.tgs';\nimport DiscussionGroups from '../../../assets/tgs/settings/DiscussionGroupsDucks.tgs';\n\nimport CameraFlip from '../../../assets/tgs/calls/CameraFlip.tgs';\nimport HandFilled from '../../../assets/tgs/calls/HandFilled.tgs';\nimport HandOutline from '../../../assets/tgs/calls/HandOutline.tgs';\nimport Speaker from '../../../assets/tgs/calls/Speaker.tgs';\nimport VoiceAllowTalk from '../../../assets/tgs/calls/VoiceAllowTalk.tgs';\nimport VoiceMini from '../../../assets/tgs/calls/VoiceMini.tgs';\nimport VoiceMuted from '../../../assets/tgs/calls/VoiceMuted.tgs';\nimport VoiceOutlined from '../../../assets/tgs/calls/VoiceOutlined.tgs';\n\nimport Peach from '../../../assets/tgs/animatedEmojis/Peach.tgs';\nimport Eggplant from '../../../assets/tgs/animatedEmojis/Eggplant.tgs';\nimport Cumshot from '../../../assets/tgs/animatedEmojis/Cumshot.tgs';\n\nimport JoinRequest from '../../../assets/tgs/invites/Requests.tgs';\nimport Invite from '../../../assets/tgs/invites/Invite.tgs';\n\nexport const ANIMATED_STICKERS_PATHS = {\n  MonkeyIdle,\n  MonkeyTracking,\n  MonkeyClose,\n  MonkeyPeek,\n  FoldersAll,\n  FoldersNew,\n  DiscussionGroups,\n  CameraFlip,\n  HandFilled,\n  HandOutline,\n  Speaker,\n  VoiceAllowTalk,\n  VoiceMini,\n  VoiceMuted,\n  VoiceOutlined,\n  Peach,\n  Eggplant,\n  Cumshot,\n  JoinRequest,\n  Invite,\n};\n\nexport default function getAnimationData(name: keyof typeof ANIMATED_STICKERS_PATHS) {\n  const path = ANIMATED_STICKERS_PATHS[name].replace(window.location.origin, '');\n\n  return mediaLoader.fetch(`file${path}`, ApiMediaFormat.Lottie);\n}\n","import React, { FC, memo } from '../../lib/teact/teact';\n\nimport useLang from '../../hooks/useLang';\nimport { TextPart } from '../common/helpers/renderMessageText';\n\nimport Modal from './Modal';\nimport Button from './Button';\n\ntype OwnProps = {\n  isOpen: boolean;\n  onClose: () => void;\n  onCloseAnimationEnd?: () => void;\n  title?: string;\n  header?: FC;\n  textParts?: TextPart[];\n  text?: string;\n  confirmLabel?: string;\n  confirmHandler: () => void;\n  confirmIsDestructive?: boolean;\n  isButtonsInOneRow?: boolean;\n  children?: any;\n};\n\nconst ConfirmDialog: FC<OwnProps> = ({\n  isOpen,\n  onClose,\n  onCloseAnimationEnd,\n  title,\n  header,\n  text,\n  textParts,\n  confirmLabel = 'Confirm',\n  confirmHandler,\n  confirmIsDestructive,\n  isButtonsInOneRow,\n  children,\n}) => {\n  const lang = useLang();\n\n  return (\n    <Modal\n      className=\"confirm\"\n      title={title}\n      header={header}\n      isOpen={isOpen}\n      onClose={onClose}\n      onCloseAnimationEnd={onCloseAnimationEnd}\n      onEnter={confirmHandler}\n    >\n      {text && text.split('\\\\n').map((textPart) => (\n        <p>{textPart}</p>\n      ))}\n      {textParts || children}\n      <div className={isButtonsInOneRow ? 'dialog-buttons mt-2' : ''}>\n        <Button\n          className=\"confirm-dialog-button\"\n          isText\n          onClick={confirmHandler}\n          color={confirmIsDestructive ? 'danger' : 'primary'}\n        >\n          {confirmLabel}\n        </Button>\n        <Button className=\"confirm-dialog-button\" isText onClick={onClose}>{lang('Cancel')}</Button>\n      </div>\n    </Modal>\n  );\n};\n\nexport default memo(ConfirmDialog);\n","import { RefObject, UIEvent } from 'react';\nimport { LoadMoreDirection } from '../../types';\n\nimport React, {\n  FC, useCallback, useEffect, useLayoutEffect, useMemo, useRef,\n} from '../../lib/teact/teact';\n\nimport { debounce } from '../../util/schedulers';\nimport resetScroll from '../../util/resetScroll';\nimport { IS_ANDROID } from '../../util/environment';\n\ntype OwnProps = {\n  ref?: RefObject<HTMLDivElement>;\n  className?: string;\n  onLoadMore?: ({ direction }: { direction: LoadMoreDirection; noScroll?: boolean }) => void;\n  onScroll?: (e: UIEvent<HTMLDivElement>) => void;\n  onKeyDown?: (e: React.KeyboardEvent<any>) => void;\n  items?: any[];\n  itemSelector?: string;\n  preloadBackwards?: number;\n  sensitiveArea?: number;\n  withAbsolutePositioning?: boolean;\n  maxHeight?: number;\n  noScrollRestore?: boolean;\n  noScrollRestoreOnTop?: boolean;\n  noFastList?: boolean;\n  cacheBuster?: any;\n  children: any;\n};\n\nconst DEFAULT_LIST_SELECTOR = '.ListItem';\nconst DEFAULT_PRELOAD_BACKWARDS = 20;\nconst DEFAULT_SENSITIVE_AREA = 800;\n\nconst InfiniteScroll: FC<OwnProps> = ({\n  ref,\n  className,\n  onLoadMore,\n  onScroll,\n  onKeyDown,\n  items,\n  itemSelector = DEFAULT_LIST_SELECTOR,\n  preloadBackwards = DEFAULT_PRELOAD_BACKWARDS,\n  sensitiveArea = DEFAULT_SENSITIVE_AREA,\n  withAbsolutePositioning,\n  maxHeight,\n  // Used to turn off restoring scroll position (e.g. for frequently re-ordered chat or user lists)\n  noScrollRestore = false,\n  noScrollRestoreOnTop = false,\n  noFastList,\n  // Used to re-query `listItemElements` if rendering is delayed by transition\n  cacheBuster,\n  children,\n}: OwnProps) => {\n  // eslint-disable-next-line no-null/no-null\n  let containerRef = useRef<HTMLDivElement>(null);\n  if (ref) {\n    containerRef = ref;\n  }\n\n  const stateRef = useRef<{\n    listItemElements?: NodeListOf<HTMLDivElement>;\n    isScrollTopJustUpdated?: boolean;\n    currentAnchor?: HTMLDivElement | undefined;\n    currentAnchorTop?: number;\n  }>({});\n\n  const [loadMoreBackwards, loadMoreForwards] = useMemo(() => {\n    if (!onLoadMore) {\n      return [];\n    }\n\n    return [\n      debounce((noScroll = false) => {\n        onLoadMore({ direction: LoadMoreDirection.Backwards, noScroll });\n      }, 1000, true, false),\n      debounce(() => {\n        onLoadMore({ direction: LoadMoreDirection.Forwards });\n      }, 1000, true, false),\n    ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [onLoadMore, items]);\n\n  // Initial preload\n  useEffect(() => {\n    if (!loadMoreBackwards) {\n      return;\n    }\n\n    if (preloadBackwards > 0 && (!items || items.length < preloadBackwards)) {\n      loadMoreBackwards(true);\n      return;\n    }\n\n    const { scrollHeight, clientHeight } = containerRef.current!;\n    if (clientHeight && scrollHeight <= clientHeight) {\n      loadMoreBackwards();\n    }\n  }, [items, loadMoreBackwards, preloadBackwards]);\n\n  // Restore `scrollTop` after adding items\n  useLayoutEffect(() => {\n    const container = containerRef.current!;\n    const state = stateRef.current;\n\n    state.listItemElements = container.querySelectorAll<HTMLDivElement>(itemSelector);\n\n    let newScrollTop;\n\n    if (state.currentAnchor && Array.from(state.listItemElements).includes(state.currentAnchor)) {\n      const { scrollTop } = container;\n      const newAnchorTop = state.currentAnchor.getBoundingClientRect().top;\n      newScrollTop = scrollTop + (newAnchorTop - state.currentAnchorTop!);\n    } else {\n      const nextAnchor = state.listItemElements[0];\n      if (nextAnchor) {\n        state.currentAnchor = nextAnchor;\n        state.currentAnchorTop = nextAnchor.getBoundingClientRect().top;\n      }\n    }\n\n    if (withAbsolutePositioning || noScrollRestore) {\n      return;\n    }\n\n    if (noScrollRestoreOnTop && container.scrollTop === 0) {\n      return;\n    }\n\n    resetScroll(container, newScrollTop);\n\n    state.isScrollTopJustUpdated = true;\n  }, [items, itemSelector, noScrollRestore, noScrollRestoreOnTop, cacheBuster, withAbsolutePositioning]);\n\n  const handleScroll = useCallback((e: UIEvent<HTMLDivElement>) => {\n    if (loadMoreForwards && loadMoreBackwards) {\n      const {\n        isScrollTopJustUpdated, currentAnchor, currentAnchorTop,\n      } = stateRef.current;\n      const listItemElements = stateRef.current.listItemElements!;\n\n      if (isScrollTopJustUpdated) {\n        stateRef.current.isScrollTopJustUpdated = false;\n        return;\n      }\n\n      const listLength = listItemElements.length;\n      const container = containerRef.current!;\n      const { scrollTop, scrollHeight, offsetHeight } = container;\n      const top = listLength ? listItemElements[0].offsetTop : 0;\n      const isNearTop = scrollTop <= top + sensitiveArea;\n      const bottom = listLength\n        ? listItemElements[listLength - 1].offsetTop + listItemElements[listLength - 1].offsetHeight\n        : scrollHeight;\n      const isNearBottom = bottom - (scrollTop + offsetHeight) <= sensitiveArea;\n      let isUpdated = false;\n\n      if (isNearTop) {\n        const nextAnchor = listItemElements[0];\n        if (nextAnchor) {\n          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;\n          const newAnchorTop = currentAnchor?.offsetParent && currentAnchor !== nextAnchor\n            ? currentAnchor.getBoundingClientRect().top\n            : nextAnchorTop;\n          const isMovingUp = (\n            currentAnchor && currentAnchorTop !== undefined && newAnchorTop > currentAnchorTop\n          );\n\n          if (isMovingUp) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchorTop;\n            isUpdated = true;\n            loadMoreForwards();\n          }\n        }\n      }\n\n      if (isNearBottom) {\n        const nextAnchor = listItemElements[listLength - 1];\n        if (nextAnchor) {\n          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;\n          const newAnchorTop = currentAnchor?.offsetParent && currentAnchor !== nextAnchor\n            ? currentAnchor.getBoundingClientRect().top\n            : nextAnchorTop;\n          const isMovingDown = (\n            currentAnchor && currentAnchorTop !== undefined && newAnchorTop < currentAnchorTop\n          );\n\n          if (isMovingDown) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchorTop;\n            isUpdated = true;\n            loadMoreBackwards();\n          }\n        }\n      }\n\n      if (!isUpdated) {\n        if (currentAnchor?.offsetParent) {\n          stateRef.current.currentAnchorTop = currentAnchor.getBoundingClientRect().top;\n        } else {\n          const nextAnchor = listItemElements[0];\n\n          if (nextAnchor) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchor.getBoundingClientRect().top;\n          }\n        }\n      }\n    }\n\n    if (onScroll) {\n      onScroll(e);\n    }\n  }, [loadMoreBackwards, loadMoreForwards, onScroll, sensitiveArea]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={className}\n      onScroll={handleScroll}\n      teactFastList={!noFastList && !withAbsolutePositioning}\n      onKeyDown={onKeyDown}\n    >\n      {withAbsolutePositioning && items?.length ? (\n        <div\n          teactFastList={!noFastList}\n          // @ts-ignore\n          style={`position: relative;${IS_ANDROID ? ` height: ${maxHeight}px;` : undefined}`}\n        >\n          {children}\n        </div>\n      ) : children}\n    </div>\n  );\n};\n\nexport default InfiniteScroll;\n","import { RefObject } from 'react';\nimport React, {\n  FC, useEffect, useRef,\n} from '../../lib/teact/teact';\n\nimport { TextPart } from '../common/helpers/renderMessageText';\n\nimport captureKeyboardListeners from '../../util/captureKeyboardListeners';\nimport trapFocus from '../../util/trapFocus';\nimport buildClassName from '../../util/buildClassName';\nimport { dispatchHeavyAnimationEvent } from '../../hooks/useHeavyAnimationCheck';\nimport useShowTransition from '../../hooks/useShowTransition';\nimport useEffectWithPrevDeps from '../../hooks/useEffectWithPrevDeps';\nimport useLang from '../../hooks/useLang';\nimport useHistoryBack from '../../hooks/useHistoryBack';\n\nimport Button from './Button';\nimport Portal from './Portal';\n\nimport './Modal.scss';\n\nconst ANIMATION_DURATION = 200;\n\ntype OwnProps = {\n  title?: string | TextPart[];\n  className?: string;\n  isOpen?: boolean;\n  header?: any;\n  hasCloseButton?: boolean;\n  noBackdrop?: boolean;\n  children: any;\n  onClose: () => void;\n  onCloseAnimationEnd?: () => void;\n  onEnter?: () => void;\n  dialogRef?: RefObject<HTMLDivElement>;\n};\n\ntype StateProps = {\n  shouldSkipHistoryAnimations?: boolean;\n};\n\nconst Modal: FC<OwnProps & StateProps> = ({\n  dialogRef,\n  title,\n  className,\n  isOpen,\n  header,\n  hasCloseButton,\n  noBackdrop,\n  children,\n  onClose,\n  onCloseAnimationEnd,\n  onEnter,\n  shouldSkipHistoryAnimations,\n}) => {\n  const {\n    shouldRender,\n    transitionClassNames,\n  } = useShowTransition(\n    isOpen, onCloseAnimationEnd, shouldSkipHistoryAnimations, undefined, shouldSkipHistoryAnimations,\n  );\n  // eslint-disable-next-line no-null/no-null\n  const modalRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => (isOpen\n    ? captureKeyboardListeners({ onEsc: onClose, onEnter })\n    : undefined), [isOpen, onClose, onEnter]);\n  useEffect(() => (isOpen && modalRef.current ? trapFocus(modalRef.current) : undefined), [isOpen]);\n\n  const { forceClose } = useHistoryBack(isOpen, onClose);\n\n  // For modals that are closed by unmounting without changing `isOpen` to `false`\n  useEffect(() => {\n    return () => {\n      if (isOpen) {\n        forceClose();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffectWithPrevDeps(([prevIsOpen]) => {\n    document.body.classList.toggle('has-open-dialog', isOpen);\n    if (isOpen || (!isOpen && prevIsOpen !== undefined)) {\n      dispatchHeavyAnimationEvent(ANIMATION_DURATION);\n    }\n\n    return () => {\n      document.body.classList.remove('has-open-dialog');\n    };\n  }, [isOpen]);\n\n  const lang = useLang();\n\n  if (!shouldRender) {\n    return undefined;\n  }\n\n  function renderHeader() {\n    if (header) {\n      return header;\n    }\n\n    if (!title) {\n      return undefined;\n    }\n\n    return (\n      <div className=\"modal-header\">\n        {hasCloseButton && (\n          <Button\n            round\n            color=\"translucent\"\n            size=\"smaller\"\n            ariaLabel={lang('Close')}\n            onClick={onClose}\n          >\n            <i className=\"icon-close\" />\n          </Button>\n        )}\n        <div className=\"modal-title\">{title}</div>\n      </div>\n    );\n  }\n\n  const fullClassName = buildClassName(\n    'Modal',\n    className,\n    transitionClassNames,\n    noBackdrop && 'transparent-backdrop',\n  );\n\n  return (\n    <Portal>\n      <div\n        ref={modalRef}\n        className={fullClassName}\n        tabIndex={-1}\n        role=\"dialog\"\n      >\n        <div className=\"modal-container\">\n          <div className=\"modal-backdrop\" onClick={onClose} />\n          <div className=\"modal-dialog\" ref={dialogRef}>\n            {renderHeader()}\n            <div className=\"modal-content custom-scroll\">\n              {children}\n            </div>\n          </div>\n        </div>\n      </div>\n    </Portal>\n  );\n};\n\nexport default Modal;\n","export default function trapFocus(element: HTMLElement) {\n  function handleKeyDown(e: KeyboardEvent) {\n    if (e.key !== 'Tab') {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const focusableElements = Array.from(\n      element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'),\n    ) as HTMLElement[];\n    if (!focusableElements.length) {\n      return;\n    }\n\n    const currentFocusedIndex = focusableElements.findIndex((em) => em.isSameNode(document.activeElement));\n    let newFocusedIndex = 0;\n    if (currentFocusedIndex >= 0) {\n      if (e.shiftKey) {\n        newFocusedIndex = currentFocusedIndex > 0\n          ? currentFocusedIndex - 1\n          : focusableElements.length - 1;\n      } else {\n        newFocusedIndex = currentFocusedIndex < focusableElements.length - 1\n          ? currentFocusedIndex + 1\n          : 0;\n      }\n    }\n\n    focusableElements[newFocusedIndex].focus();\n  }\n\n  document.addEventListener('keydown', handleKeyDown, false);\n\n  return () => {\n    document.removeEventListener('keydown', handleKeyDown, false);\n  };\n}\n","import { FC, useRef, useLayoutEffect } from '../../lib/teact/teact';\nimport TeactDOM from '../../lib/teact/teact-dom';\n\ntype OwnProps = {\n  containerId?: string;\n  className?: string;\n  children: any;\n};\n\nconst Portal: FC<OwnProps> = ({ containerId, className, children }) => {\n  const elementRef = useRef<HTMLDivElement>();\n  if (!elementRef.current) {\n    elementRef.current = document.createElement('div');\n  }\n\n  useLayoutEffect(() => {\n    const container = document.querySelector<HTMLDivElement>(containerId || '#portals');\n    if (!container) {\n      return undefined;\n    }\n\n    const element = elementRef.current!;\n    if (className) {\n      element.classList.add(className);\n    }\n\n    container.appendChild(element);\n\n    return () => {\n      TeactDOM.render(undefined, element);\n      container.removeChild(element);\n    };\n  }, [className, containerId]);\n\n  return TeactDOM.render(children, elementRef.current);\n};\n\nexport default Portal;\n","import { useEffect } from '../lib/teact/teact';\n\nexport default function useBackgroundMode(\n  onBlur?: AnyToVoidFunction,\n  onFocus?: AnyToVoidFunction,\n) {\n  useEffect(() => {\n    if (onBlur && !document.hasFocus()) {\n      onBlur();\n    }\n\n    if (onBlur) {\n      window.addEventListener('blur', onBlur);\n    }\n\n    if (onFocus) {\n      window.addEventListener('focus', onFocus);\n    }\n\n    return () => {\n      if (onFocus) {\n        window.removeEventListener('focus', onFocus);\n      }\n\n      if (onBlur) {\n        window.removeEventListener('blur', onBlur);\n      }\n    };\n  }, [onBlur, onFocus]);\n}\n","import usePrevious from './usePrevious';\n\nexport default function useCurrentOrPrev<T extends any>(\n  current: T, shouldSkipUndefined = false, shouldForceCurrent = false,\n): T | undefined {\n  const prev = usePrevious(current, shouldSkipUndefined);\n\n  // eslint-disable-next-line no-null/no-null\n  return shouldForceCurrent || (current !== null && current !== undefined) ? current : prev;\n}\n","import { useCallback, useEffect, useRef } from '../lib/teact/teact';\nimport { LoadMoreDirection } from '../types';\n\nimport { areSortedArraysEqual } from '../util/iteratees';\nimport useForceUpdate from './useForceUpdate';\nimport usePrevious from './usePrevious';\n\ntype GetMore = (args: { direction: LoadMoreDirection }) => void;\ntype LoadMoreBackwards = (args: { offsetId?: string | number }) => void;\n\nconst DEFAULT_LIST_SLICE = 30;\n\nconst useInfiniteScroll = <ListId extends string | number>(\n  loadMoreBackwards?: LoadMoreBackwards,\n  listIds?: ListId[],\n  isDisabled = false,\n  listSlice = DEFAULT_LIST_SLICE,\n  forceFullPreload = false,\n): [ListId[]?, GetMore?] => {\n  const lastParamsRef = useRef<{\n    direction?: LoadMoreDirection;\n    offsetId?: ListId;\n  }>();\n\n  const viewportIdsRef = useRef<ListId[] | undefined>((() => {\n    // Only run once to initialize\n    if (!listIds || lastParamsRef.current) {\n      return undefined;\n    }\n\n    const { newViewportIds } = getViewportSlice(listIds, LoadMoreDirection.Forwards, listSlice, listIds[0]);\n    return newViewportIds;\n  })());\n\n  const forceUpdate = useForceUpdate();\n\n  if (isDisabled) {\n    lastParamsRef.current = {};\n  }\n\n  const prevListIds = usePrevious(listIds);\n  const prevIsDisabled = usePrevious(isDisabled);\n  if (listIds && !isDisabled && (listIds !== prevListIds || isDisabled !== prevIsDisabled)) {\n    const { offsetId = listIds[0], direction = LoadMoreDirection.Forwards } = lastParamsRef.current || {};\n    const { newViewportIds } = getViewportSlice(listIds, direction, listSlice, offsetId);\n\n    if (!viewportIdsRef.current || !areSortedArraysEqual(viewportIdsRef.current, newViewportIds)) {\n      viewportIdsRef.current = newViewportIds;\n    }\n  }\n\n  useEffect(() => {\n    if (listIds && !isDisabled && loadMoreBackwards && forceFullPreload) {\n      const viewportIds = viewportIdsRef.current!;\n      loadMoreBackwards({ offsetId: viewportIds[viewportIds.length - 1] });\n    }\n  }, [listIds, isDisabled, loadMoreBackwards, forceFullPreload]);\n\n  const getMore: GetMore = useCallback(({\n    direction,\n    noScroll,\n  }: { direction: LoadMoreDirection; noScroll?: boolean }) => {\n    const viewportIds = viewportIdsRef.current;\n\n    const offsetId = viewportIds\n      ? direction === LoadMoreDirection.Backwards ? viewportIds[viewportIds.length - 1] : viewportIds[0]\n      : undefined;\n\n    if (!listIds) {\n      if (loadMoreBackwards) {\n        loadMoreBackwards({ offsetId });\n      }\n\n      return;\n    }\n\n    if (!noScroll) {\n      lastParamsRef.current = { ...lastParamsRef.current, direction, offsetId };\n    }\n\n    const {\n      newViewportIds, areSomeLocal, areAllLocal,\n    } = getViewportSlice(listIds, direction, listSlice, offsetId);\n\n    if (areSomeLocal && !(viewportIds && areSortedArraysEqual(viewportIds, newViewportIds))) {\n      viewportIdsRef.current = newViewportIds;\n      forceUpdate();\n    }\n\n    if (!areAllLocal && loadMoreBackwards) {\n      loadMoreBackwards({ offsetId });\n    }\n  }, [listIds, listSlice, loadMoreBackwards, forceUpdate]);\n\n  return isDisabled ? [listIds] : [viewportIdsRef.current, getMore];\n};\n\nfunction getViewportSlice<ListId extends string | number>(\n  sourceIds: ListId[],\n  direction: LoadMoreDirection,\n  listSlice: number,\n  offsetId?: ListId,\n) {\n  const { length } = sourceIds;\n  const index = offsetId ? sourceIds.indexOf(offsetId) : 0;\n  const isForwards = direction === LoadMoreDirection.Forwards;\n  const indexForDirection = isForwards ? index : (index + 1) || length;\n  const from = Math.max(0, indexForDirection - listSlice);\n  const to = indexForDirection + listSlice - 1;\n  const newViewportIds = sourceIds.slice(Math.max(0, from), to + 1);\n\n  let areSomeLocal;\n  let areAllLocal;\n  switch (direction) {\n    case LoadMoreDirection.Forwards:\n      areSomeLocal = indexForDirection > 0;\n      areAllLocal = from >= 0;\n      break;\n    case LoadMoreDirection.Backwards:\n      areSomeLocal = indexForDirection < length;\n      areAllLocal = to <= length - 1;\n      break;\n  }\n\n  return { newViewportIds, areSomeLocal, areAllLocal };\n}\n\nexport default useInfiniteScroll;\n","import { useEffect } from '../lib/teact/teact';\n\nimport { ApiMediaFormat } from '../api/types';\n\nimport * as mediaLoader from '../util/mediaLoader';\nimport useForceUpdate from './useForceUpdate';\n\nconst useMedia =  <T extends ApiMediaFormat = ApiMediaFormat.BlobUrl>(\n  mediaHash: string | false | undefined,\n  noLoad = false,\n  // @ts-ignore (workaround for \"could be instantiated with a different subtype\" issue)\n  mediaFormat: T = ApiMediaFormat.BlobUrl,\n  cacheBuster?: number,\n  delay?: number | false,\n) => {\n  const mediaData = mediaHash ? mediaLoader.getFromMemory(mediaHash) : undefined;\n  const forceUpdate = useForceUpdate();\n\n  useEffect(() => {\n    if (!noLoad && mediaHash && !mediaData) {\n      const startedAt = Date.now();\n\n      mediaLoader.fetch(mediaHash, mediaFormat).then(() => {\n        const spentTime = Date.now() - startedAt;\n        if (!delay || spentTime >= delay) {\n          forceUpdate();\n        } else {\n          setTimeout(forceUpdate, delay - spentTime);\n        }\n      });\n    }\n  }, [noLoad, mediaHash, mediaData, mediaFormat, cacheBuster, forceUpdate, delay]);\n\n  return mediaData;\n};\n\nexport default useMedia;\n","import { DEBUG } from '../config';\n\nexport const CLIPBOARD_ITEM_SUPPORTED = navigator.clipboard && window.ClipboardItem;\n\nconst textCopyEl = document.createElement('textarea');\ntextCopyEl.setAttribute('readonly', '');\ntextCopyEl.tabIndex = -1;\ntextCopyEl.className = 'visually-hidden';\n\nexport const copyTextToClipboard = (str: string): void => {\n  textCopyEl.value = str;\n  document.body.appendChild(textCopyEl);\n  const selection = document.getSelection();\n\n  if (selection) {\n    // Store previous selection\n    const rangeToRestore = selection.rangeCount > 0 && selection.getRangeAt(0);\n    textCopyEl.select();\n    document.execCommand('copy');\n    // Restore the original selection\n    if (rangeToRestore) {\n      selection.removeAllRanges();\n      selection.addRange(rangeToRestore);\n    }\n  }\n\n  document.body.removeChild(textCopyEl);\n};\n\nexport const copyImageToClipboard = (imageUrl?: string) => {\n  if (!imageUrl) return;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const imageEl = new Image();\n  imageEl.onload = (e: Event) => {\n    if (ctx && e.currentTarget) {\n      const img = e.currentTarget as HTMLImageElement;\n      canvas.width = img.width;\n      canvas.height = img.height;\n      ctx.drawImage(img, 0, 0, img.width, img.height);\n      canvas.toBlob(copyBlobToClipboard, 'image/png', 1);\n    }\n  };\n\n  imageEl.src = imageUrl;\n};\n\nasync function copyBlobToClipboard(pngBlob: Blob | null) {\n  if (!pngBlob || !CLIPBOARD_ITEM_SUPPORTED) {\n    return;\n  }\n\n  try {\n    await navigator.clipboard.write?.([\n      new ClipboardItem({\n        [pngBlob.type]: pngBlob,\n      }),\n    ]);\n  } catch (error) {\n    if (DEBUG) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n}\n","import { addCallback, getGlobal } from '../lib/teact/teactn';\n\nimport { GlobalState } from '../global/types';\nimport { NotifyException, NotifySettings } from '../types';\nimport { ApiChat, ApiChatFolder, ApiUser } from '../api/types';\n\nimport { ALL_FOLDER_ID, ARCHIVED_FOLDER_ID, DEBUG } from '../config';\nimport { selectNotifySettings, selectNotifyExceptions } from '../modules/selectors';\nimport { selectIsChatMuted } from '../modules/helpers';\nimport { onIdle, throttle } from './schedulers';\nimport { areSortedArraysEqual, unique } from './iteratees';\nimport arePropsShallowEqual from './arePropsShallowEqual';\nimport { CallbackManager, createCallbackManager } from './callbacks';\n\ninterface FolderSummary {\n  id: number;\n  listIds?: Set<string>;\n  orderedPinnedIds?: string[];\n  contacts?: true;\n  nonContacts?: true;\n  groups?: true;\n  channels?: true;\n  bots?: true;\n  excludeMuted?: true;\n  excludeRead?: true;\n  excludeArchived?: true;\n  excludedChatIds?: Set<string>;\n  includedChatIds?: Set<string>;\n  pinnedChatIds?: Set<string>;\n}\n\ninterface ChatSummary {\n  id: string;\n  type: ApiChat['type'];\n  isListed: boolean;\n  isArchived: boolean;\n  isMuted: boolean;\n  isUnread: boolean;\n  unreadCount?: number;\n  unreadMentionsCount?: number;\n  order: number;\n  isUserBot?: boolean;\n  isUserContact?: boolean;\n}\n\nconst UPDATE_THROTTLE = 500;\nconst DEBUG_DURATION_LIMIT = 6;\n\nconst prevGlobal: {\n  allFolderListIds?: GlobalState['chats']['listIds']['active'];\n  allFolderPinnedIds?: GlobalState['chats']['orderedPinnedIds']['active'];\n  archivedFolderListIds?: GlobalState['chats']['listIds']['archived'];\n  archivedFolderPinnedIds?: GlobalState['chats']['orderedPinnedIds']['archived'];\n  chatsById: Record<string, ApiChat>;\n  foldersById: Record<string, ApiChatFolder>;\n  usersById: Record<string, ApiUser>;\n  notifySettings: NotifySettings;\n  notifyExceptions?: Record<number, NotifyException>;\n} = {\n  foldersById: {},\n  chatsById: {},\n  usersById: {},\n  notifySettings: {} as NotifySettings,\n  notifyExceptions: {},\n};\n\nconst prepared: {\n  folderSummariesById: Record<string, FolderSummary>;\n  chatSummariesById: Map<string, ChatSummary>;\n  folderIdsByChatId: Record<string, number[]>;\n  chatIdsByFolderId: Record<number, Set<string>>;\n  isOrderedListJustPatched: Record<number, boolean | undefined>;\n} = {\n  folderSummariesById: {},\n  chatSummariesById: new Map(),\n  folderIdsByChatId: {},\n  chatIdsByFolderId: {},\n  isOrderedListJustPatched: {},\n};\n\nconst results: {\n  orderedIdsByFolderId: Record<string, string[] | undefined>;\n  chatsCountByFolderId: Record<string, number | undefined>;\n  unreadCountersByFolderId: Record<string, {\n    chatsCount: number;\n    notificationsCount: number;\n  } | undefined>;\n} = {\n  orderedIdsByFolderId: {},\n  chatsCountByFolderId: {},\n  unreadCountersByFolderId: {},\n};\n\nconst callbacks: {\n  orderedIdsByFolderId: Record<number, CallbackManager>;\n  chatsCountByFolderId: CallbackManager;\n  unreadCountersByFolderId: CallbackManager;\n} = {\n  orderedIdsByFolderId: {},\n  chatsCountByFolderId: createCallbackManager(),\n  unreadCountersByFolderId: createCallbackManager(),\n};\n\nconst updateFolderManagerThrottled = throttle(() => {\n  onIdle(() => {\n    updateFolderManager(getGlobal());\n  });\n}, UPDATE_THROTTLE);\n\nlet inited = false;\n\nfunction init() {\n  addCallback(updateFolderManagerThrottled);\n  updateFolderManager(getGlobal());\n}\n\n/* Getters */\n\nexport function getOrderedIds(folderId: number) {\n  if (!inited) init();\n\n  return results.orderedIdsByFolderId[folderId];\n}\n\nexport function getChatsCount() {\n  if (!inited) init();\n\n  return results.chatsCountByFolderId;\n}\n\nexport function getUnreadCounters() {\n  if (!inited) init();\n\n  return results.unreadCountersByFolderId;\n}\n\nexport function getAllNotificationsCount() {\n  return getUnreadCounters()[ALL_FOLDER_ID]?.notificationsCount || 0;\n}\n\nexport function getPinnedChatsCount(folderId: number) {\n  return prepared.folderSummariesById[folderId]?.pinnedChatIds?.size;\n}\n\n/* Callback managers */\n\nexport function addOrderedIdsCallback(folderId: number, callback: (orderedIds: string[]) => void) {\n  if (!callbacks.orderedIdsByFolderId[folderId]) {\n    callbacks.orderedIdsByFolderId[folderId] = createCallbackManager();\n  }\n\n  return callbacks.orderedIdsByFolderId[folderId].addCallback(callback);\n}\n\nexport function addChatsCountCallback(callback: (chatsCount: typeof results.chatsCountByFolderId) => void) {\n  return callbacks.chatsCountByFolderId.addCallback(callback);\n}\n\nexport function addUnreadCountersCallback(callback: (unreadCounters: typeof results.unreadCountersByFolderId) => void) {\n  return callbacks.unreadCountersByFolderId.addCallback(callback);\n}\n\n/* Global update handlers */\n\nfunction updateFolderManager(global: GlobalState) {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  let DEBUG_startedAt: number;\n  if (DEBUG) {\n    DEBUG_startedAt = performance.now();\n  }\n\n  const isAllFolderChanged = Boolean(\n    global.chats.listIds.active\n    && isMainFolderChanged(ALL_FOLDER_ID, global.chats.listIds.active, global.chats.orderedPinnedIds.active),\n  );\n  const isArchivedFolderChanged = Boolean(\n    global.chats.listIds.archived\n    && isMainFolderChanged(ARCHIVED_FOLDER_ID, global.chats.listIds.archived, global.chats.orderedPinnedIds.archived),\n  );\n\n  const areFoldersChanged = global.chatFolders.byId !== prevGlobal.foldersById;\n  const areChatsChanged = global.chats.byId !== prevGlobal.chatsById;\n  const areUsersChanged = global.users.byId !== prevGlobal.usersById;\n  const areNotifySettingsChanged = selectNotifySettings(global) !== prevGlobal.notifySettings;\n  const areNotifyExceptionsChanged = selectNotifyExceptions(global) !== prevGlobal.notifyExceptions;\n\n  if (!(\n    isAllFolderChanged || isArchivedFolderChanged || areFoldersChanged\n    || areChatsChanged || areUsersChanged || areNotifySettingsChanged || areNotifyExceptionsChanged\n  )\n  ) {\n    return;\n  }\n\n  const prevAllFolderListIds = prevGlobal.allFolderListIds;\n  const prevArchivedFolderListIds = prevGlobal.archivedFolderListIds;\n\n  updateFolders(global, isAllFolderChanged, isArchivedFolderChanged, areFoldersChanged);\n\n  const affectedFolderIds = updateChats(\n    global, areFoldersChanged, areNotifySettingsChanged, areNotifyExceptionsChanged,\n    prevAllFolderListIds, prevArchivedFolderListIds,\n  );\n\n  updateResults(affectedFolderIds);\n\n  if (DEBUG) {\n    const duration = performance.now() - DEBUG_startedAt!;\n    if (duration > DEBUG_DURATION_LIMIT) {\n      // eslint-disable-next-line no-console\n      console.warn(`Slow \\`updateFolderManager\\`: ${Math.round(duration)} ms`);\n    }\n  }\n}\n\nfunction isMainFolderChanged(folderId: number, newListIds?: string[], newPinnedIds?: string[]) {\n  const currentListIds = folderId === ALL_FOLDER_ID\n    ? prevGlobal.allFolderListIds\n    : prevGlobal.archivedFolderListIds;\n  const currentPinnedIds = folderId === ALL_FOLDER_ID\n    ? prevGlobal.allFolderPinnedIds\n    : prevGlobal.archivedFolderPinnedIds;\n\n  return currentListIds !== newListIds || currentPinnedIds !== newPinnedIds;\n}\n\nfunction updateFolders(\n  global: GlobalState, isAllFolderChanged: boolean, isArchivedFolderChanged: boolean, areFoldersChanged: boolean,\n) {\n  const changedFolders = [];\n\n  if (isAllFolderChanged) {\n    const newListIds = global.chats.listIds.active!;\n    const newPinnedIds = global.chats.orderedPinnedIds.active;\n\n    prepared.folderSummariesById[ALL_FOLDER_ID] = buildFolderSummaryFromMainList(\n      ALL_FOLDER_ID, newListIds, newPinnedIds,\n    );\n\n    prevGlobal.allFolderListIds = newListIds;\n    prevGlobal.allFolderPinnedIds = newPinnedIds;\n\n    changedFolders.push(ALL_FOLDER_ID);\n  }\n\n  if (isArchivedFolderChanged) {\n    const newListIds = global.chats.listIds.archived!;\n    const newPinnedIds = global.chats.orderedPinnedIds.archived;\n\n    prepared.folderSummariesById[ARCHIVED_FOLDER_ID] = buildFolderSummaryFromMainList(\n      ARCHIVED_FOLDER_ID, newListIds, newPinnedIds,\n    );\n\n    prevGlobal.archivedFolderListIds = newListIds;\n    prevGlobal.archivedFolderPinnedIds = newPinnedIds;\n\n    changedFolders.push(ARCHIVED_FOLDER_ID);\n  }\n\n  if (areFoldersChanged) {\n    const newFoldersById = global.chatFolders.byId;\n\n    Object.values(newFoldersById).forEach((folder) => {\n      if (folder === prevGlobal.foldersById[folder.id]) {\n        return;\n      }\n\n      prepared.folderSummariesById[folder.id] = buildFolderSummary(folder);\n\n      changedFolders.push(folder.id);\n    });\n\n    prevGlobal.foldersById = newFoldersById;\n  }\n\n  return changedFolders;\n}\n\nfunction buildFolderSummaryFromMainList(\n  folderId: number, listIds: string[], orderedPinnedIds?: string[],\n): FolderSummary {\n  return {\n    id: folderId,\n    listIds: new Set(listIds),\n    orderedPinnedIds: orderedPinnedIds,\n    pinnedChatIds: new Set(orderedPinnedIds),\n  };\n}\n\nfunction buildFolderSummary(folder: ApiChatFolder): FolderSummary {\n  return {\n    ...folder,\n    orderedPinnedIds: folder.pinnedChatIds,\n    excludedChatIds: folder.excludedChatIds ? new Set(folder.excludedChatIds) : undefined,\n    includedChatIds: folder.excludedChatIds ? new Set(folder.includedChatIds) : undefined,\n    pinnedChatIds: folder.excludedChatIds ? new Set(folder.pinnedChatIds) : undefined,\n  };\n}\n\nfunction updateChats(\n  global: GlobalState,\n  areFoldersChanged: boolean,\n  areNotifySettingsChanged: boolean,\n  areNotifyExceptionsChanged: boolean,\n  prevAllFolderListIds?: string[],\n  prevArchivedFolderListIds?: string[],\n) {\n  const newChatsById = global.chats.byId;\n  const newUsersById = global.users.byId;\n  const newNotifySettings = selectNotifySettings(global);\n  const newNotifyExceptions = selectNotifyExceptions(global);\n  const folderSummaries = Object.values(prepared.folderSummariesById);\n  const affectedFolderIds = new Set<number>();\n\n  const newAllFolderListIds = global.chats.listIds.active;\n  const newArchivedFolderListIds = global.chats.listIds.archived;\n  let allIds = [...newAllFolderListIds || [], ...newArchivedFolderListIds || []];\n  if (newAllFolderListIds !== prevAllFolderListIds || newArchivedFolderListIds !== prevArchivedFolderListIds) {\n    allIds = unique(allIds.concat(prevAllFolderListIds || [], prevArchivedFolderListIds || []));\n  }\n\n  allIds.forEach((chatId) => {\n    const chat = newChatsById[chatId];\n\n    if (\n      !areFoldersChanged\n      && !areNotifySettingsChanged\n      && !areNotifyExceptionsChanged\n      && chat === prevGlobal.chatsById[chatId]\n      && newUsersById[chatId] === prevGlobal.usersById[chatId]\n    ) {\n      return;\n    }\n\n    let newFolderIds: number[];\n    if (chat) {\n      const currentSummary = prepared.chatSummariesById.get(chatId);\n      const newSummary = buildChatSummary(chat, newNotifySettings, newNotifyExceptions, newUsersById[chatId]);\n      if (!areFoldersChanged && currentSummary && arePropsShallowEqual(newSummary, currentSummary)) {\n        return;\n      }\n\n      prepared.chatSummariesById.set(chatId, newSummary);\n\n      newFolderIds = buildChatFolderIds(newSummary, folderSummaries);\n      newFolderIds.forEach((folderId) => {\n        affectedFolderIds.add(folderId);\n      });\n    } else {\n      prepared.chatSummariesById.delete(chatId);\n      newFolderIds = [];\n    }\n\n    const currentFolderIds = prepared.folderIdsByChatId[chatId] || [];\n    if (areSortedArraysEqual(newFolderIds, currentFolderIds)) {\n      return;\n    }\n\n    const deletedFolderIds = updateListsForChat(chatId, currentFolderIds, newFolderIds);\n    deletedFolderIds.forEach((folderId) => {\n      affectedFolderIds.add(folderId);\n    });\n  });\n\n  prevGlobal.chatsById = newChatsById;\n  prevGlobal.usersById = newUsersById;\n  prevGlobal.notifySettings = newNotifySettings;\n  prevGlobal.notifyExceptions = newNotifyExceptions;\n\n  return Array.from(affectedFolderIds);\n}\n\nfunction buildChatSummary(\n  chat: ApiChat,\n  notifySettings: NotifySettings,\n  notifyExceptions?: Record<number, NotifyException>,\n  user?: ApiUser,\n): ChatSummary {\n  const {\n    id, type, lastMessage, isRestricted, isNotJoined, folderId,\n    unreadCount, unreadMentionsCount, hasUnreadMark,\n    joinDate, draftDate,\n  } = chat;\n\n  const userInfo = type === 'chatTypePrivate' && user;\n\n  return {\n    id,\n    type,\n    isListed: Boolean(lastMessage && !isRestricted && !isNotJoined),\n    isArchived: folderId === ARCHIVED_FOLDER_ID,\n    isMuted: selectIsChatMuted(chat, notifySettings, notifyExceptions),\n    isUnread: Boolean(unreadCount || unreadMentionsCount || hasUnreadMark),\n    unreadCount,\n    unreadMentionsCount,\n    order: Math.max(joinDate || 0, draftDate || 0, lastMessage?.date || 0),\n    isUserBot: userInfo ? userInfo.type === 'userTypeBot' : undefined,\n    isUserContact: userInfo ? userInfo.isContact : undefined,\n  };\n}\n\nfunction buildChatFolderIds(chatSummary: ChatSummary, folderSummaries: FolderSummary[]) {\n  return folderSummaries.reduce<number[]>((acc, folderSummary) => {\n    if (isChatInFolder(chatSummary, folderSummary)) {\n      acc.push(folderSummary.id);\n    }\n\n    return acc;\n  }, []).sort();\n}\n\nfunction isChatInFolder(\n  chatSummary: ChatSummary,\n  folderSummary: FolderSummary,\n) {\n  if (!chatSummary.isListed) {\n    return false;\n  }\n\n  const { id: chatId, type } = chatSummary;\n\n  if (folderSummary.listIds) {\n    if (\n      (chatSummary.isArchived && folderSummary.id === ALL_FOLDER_ID)\n      || (!chatSummary.isArchived && folderSummary.id === ARCHIVED_FOLDER_ID)\n    ) {\n      return false;\n    }\n\n    return folderSummary.listIds.has(chatId);\n  }\n\n  if (folderSummary.excludedChatIds?.has(chatId)) {\n    return false;\n  }\n\n  if (folderSummary.includedChatIds?.has(chatId)) {\n    return true;\n  }\n\n  if (folderSummary.pinnedChatIds?.has(chatId)) {\n    return true;\n  }\n\n  if (folderSummary.excludeArchived && chatSummary.isArchived) {\n    return false;\n  }\n\n  if (folderSummary.excludeRead && !chatSummary.isUnread) {\n    return false;\n  }\n\n  if (folderSummary.excludeMuted && chatSummary.isMuted && !chatSummary.unreadMentionsCount) {\n    return false;\n  }\n\n  if (type === 'chatTypePrivate') {\n    if (chatSummary.isUserBot) {\n      if (folderSummary.bots) {\n        return true;\n      }\n    } else {\n      if (folderSummary.contacts && chatSummary.isUserContact) {\n        return true;\n      }\n\n      if (folderSummary.nonContacts && !chatSummary.isUserContact) {\n        return true;\n      }\n    }\n  } else if (type === 'chatTypeChannel') {\n    return Boolean(folderSummary.channels);\n  } else if (type === 'chatTypeBasicGroup' || type === 'chatTypeSuperGroup') {\n    return Boolean(folderSummary.groups);\n  }\n\n  return false;\n}\n\nfunction updateListsForChat(chatId: string, currentFolderIds: number[], newFolderIds: number[]) {\n  const currentFolderIdsSet = new Set(currentFolderIds);\n  const newFolderIdsSet = new Set(newFolderIds);\n  const deletedFolderIds: number[] = [];\n\n  unique([...currentFolderIds, ...newFolderIds]).forEach((folderId) => {\n    let currentFolderOrderedIds = results.orderedIdsByFolderId[folderId];\n\n    if (currentFolderIdsSet.has(folderId) && !newFolderIdsSet.has(folderId)) {\n      prepared.chatIdsByFolderId[folderId].delete(chatId);\n\n      deletedFolderIds.push(folderId);\n\n      if (currentFolderOrderedIds) {\n        currentFolderOrderedIds = currentFolderOrderedIds.filter((id) => id !== chatId);\n        prepared.isOrderedListJustPatched[folderId] = true;\n      }\n    } else if (!currentFolderIdsSet.has(folderId) && newFolderIdsSet.has(folderId)) {\n      if (!prepared.chatIdsByFolderId[folderId]) {\n        prepared.chatIdsByFolderId[folderId] = new Set();\n      }\n\n      prepared.chatIdsByFolderId[folderId].add(chatId);\n\n      if (currentFolderOrderedIds) {\n        currentFolderOrderedIds.push(chatId);\n        prepared.isOrderedListJustPatched[folderId] = true;\n      }\n    }\n\n    results.orderedIdsByFolderId[folderId] = currentFolderOrderedIds;\n  });\n\n  prepared.folderIdsByChatId[chatId] = newFolderIds;\n\n  return deletedFolderIds;\n}\n\nfunction updateResults(affectedFolderIds: number[]) {\n  let wasUnreadCountersChanged = false;\n  let wasChatsCountChanged = false;\n\n  Array.from(affectedFolderIds).forEach((folderId) => {\n    const newOrderedIds = buildFolderOrderedIds(folderId);\n\n    const currentOrderedIds = results.orderedIdsByFolderId[folderId];\n    const areOrderedIdsChanged = (\n      !currentOrderedIds\n      || prepared.isOrderedListJustPatched[folderId]\n      || !areSortedArraysEqual(newOrderedIds, currentOrderedIds)\n    );\n    if (areOrderedIdsChanged) {\n      prepared.isOrderedListJustPatched[folderId] = false;\n      results.orderedIdsByFolderId[folderId] = newOrderedIds;\n      callbacks.orderedIdsByFolderId[folderId]?.runCallbacks(newOrderedIds);\n    }\n\n    const currentChatsCount = results.chatsCountByFolderId[folderId];\n    const newChatsCount = newOrderedIds.length;\n    if (!wasChatsCountChanged) {\n      wasChatsCountChanged = currentChatsCount !== newChatsCount;\n    }\n    results.chatsCountByFolderId[folderId] = newChatsCount;\n\n    const currentUnreadCounters = results.unreadCountersByFolderId[folderId];\n    const newUnreadCounters = buildFolderUnreadCounters(folderId);\n    if (!wasUnreadCountersChanged) {\n      wasUnreadCountersChanged = (\n        !currentUnreadCounters || !arePropsShallowEqual(newUnreadCounters, currentUnreadCounters)\n      );\n    }\n    results.unreadCountersByFolderId[folderId] = newUnreadCounters;\n  });\n\n  if (wasChatsCountChanged) {\n    // We need to update the entire object as it will be returned from a hook\n    const newValue = { ...results.chatsCountByFolderId };\n    results.chatsCountByFolderId = newValue;\n    callbacks.chatsCountByFolderId.runCallbacks(newValue);\n  }\n\n  if (wasUnreadCountersChanged) {\n    // We need to update the entire object as it will be returned from a hook\n    const newValue = { ...results.unreadCountersByFolderId };\n    results.unreadCountersByFolderId = newValue;\n    callbacks.unreadCountersByFolderId.runCallbacks(newValue);\n  }\n}\n\nfunction buildFolderOrderedIds(folderId: number) {\n  const {\n    folderSummariesById: { [folderId]: { orderedPinnedIds, pinnedChatIds } },\n    chatSummariesById,\n    chatIdsByFolderId: { [folderId]: chatIds },\n  } = prepared;\n  const {\n    orderedIdsByFolderId: { [folderId]: prevOrderedIds },\n  } = results;\n\n  const allListIds = prevOrderedIds || Array.from(chatIds);\n  const notPinnedIds = pinnedChatIds ? allListIds.filter((id) => !pinnedChatIds.has(id)) : allListIds;\n  const sortedNotPinnedIds = notPinnedIds.sort((chatId1: string, chatId2: string) => {\n    return chatSummariesById.get(chatId2)!.order - chatSummariesById.get(chatId1)!.order;\n  });\n\n  return [\n    ...(orderedPinnedIds || []),\n    ...sortedNotPinnedIds,\n  ];\n}\n\nfunction buildFolderUnreadCounters(folderId: number) {\n  const {\n    chatSummariesById,\n  } = prepared;\n  const {\n    orderedIdsByFolderId: { [folderId]: orderedIds },\n  } = results;\n\n  return orderedIds!.reduce((newUnreadCounters, chatId) => {\n    const chatSummary = chatSummariesById.get(chatId);\n    if (!chatSummary) {\n      return newUnreadCounters;\n    }\n\n    if (chatSummary.isUnread) {\n      newUnreadCounters.chatsCount++;\n\n      if (chatSummary.unreadMentionsCount) {\n        newUnreadCounters.notificationsCount += chatSummary.unreadMentionsCount;\n      }\n\n      if (!chatSummary.isMuted) {\n        if (chatSummary.unreadCount) {\n          newUnreadCounters.notificationsCount += chatSummary.unreadCount;\n        } else if (!chatSummary.unreadMentionsCount) {\n          newUnreadCounters.notificationsCount += 1; // Manually marked unread\n        }\n      }\n    }\n\n    return newUnreadCounters;\n  }, {\n    chatsCount: 0,\n    notificationsCount: 0,\n  });\n}\n","// Used before applying CSS transition\nexport default function forceReflow(element: HTMLElement) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  element.offsetWidth;\n}\n","import { IS_IOS } from './environment';\nimport forceReflow from './forceReflow';\n\nconst resetScroll = (container: HTMLDivElement, scrollTop?: number) => {\n  if (IS_IOS) {\n    container.style.overflow = 'hidden';\n  }\n\n  if (scrollTop !== undefined) {\n    container.scrollTop = scrollTop;\n  }\n\n  if (IS_IOS) {\n    container.style.overflow = '';\n  }\n};\n\n// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1264266\nexport function patchChromiumScroll(element: HTMLElement) {\n  element.style.display = 'none';\n  forceReflow(element);\n  element.style.display = '';\n}\n\nexport default resetScroll;\n","import { DEBUG } from '../config';\n\nconst safePlay = (mediaEl: HTMLMediaElement) => {\n  mediaEl.play().catch((err) => {\n    if (DEBUG) {\n      // eslint-disable-next-line no-console\n      console.warn(err, mediaEl);\n    }\n  });\n};\n\nexport default safePlay;\n"],"names":["lottiePromise","RLottie","async","ensureLottie","default","setTimeout","memo","className","id","animationData","play","playSegment","speed","noLoop","size","quality","isLowPriority","color","forceOnHeavyAnimation","onLoad","onEnded","animation","setAnimation","useState","container","useRef","wasPlaying","isFrozen","isFirstRender","playRef","current","playSegmentRef","useEffect","exec","newAnimation","setSpeed","then","fastRaf","setColor","destroy","playAnimation","useCallback","shouldRestart","goToAndPlay","pauseAnimation","pause","freezeAnimation","isPlaying","unfreezeAnimation","unfreezeAnimationOnRaf","changeData","useHeavyAnimationCheck","useBackgroundMode","fullClassName","buildClassName","style","undefined","ref","chat","user","photo","userStatus","text","isSavedMessages","lastSyncTime","onClick","isDeleted","isDeletedUser","isReplies","isChatWithRepliesBot","imageHash","getChatAvatarHash","blobUrl","useMedia","ApiMediaFormat","hasBlobUrl","Boolean","transitionClassNames","useShowTransition","lang","useLang","content","src","alt","decoding","userFullName","getUserFullName","getFirstLetters","title","getChatTitle","isUserId","isOnline","isUserOnline","getUserColorKey","hasImage","handleClick","e","senderId","IS_TEST","renderText","ANIMATED_STICKERS_PATHS","MonkeyIdle","MonkeyTracking","MonkeyClose","MonkeyPeek","FoldersAll","FoldersNew","DiscussionGroups","CameraFlip","HandFilled","HandOutline","Speaker","VoiceAllowTalk","VoiceMini","VoiceMuted","VoiceOutlined","Peach","Eggplant","Cumshot","JoinRequest","Invite","getAnimationData","name","path","replace","window","location","origin","mediaLoader","isOpen","onClose","onCloseAnimationEnd","header","textParts","confirmLabel","confirmHandler","confirmIsDestructive","isButtonsInOneRow","children","onEnter","split","map","textPart","isText","DEFAULT_LIST_SELECTOR","DEFAULT_PRELOAD_BACKWARDS","DEFAULT_SENSITIVE_AREA","onLoadMore","onScroll","onKeyDown","items","itemSelector","preloadBackwards","sensitiveArea","withAbsolutePositioning","maxHeight","noScrollRestore","noScrollRestoreOnTop","noFastList","cacheBuster","containerRef","stateRef","loadMoreBackwards","loadMoreForwards","useMemo","debounce","noScroll","direction","LoadMoreDirection","length","scrollHeight","clientHeight","useLayoutEffect","state","newScrollTop","listItemElements","querySelectorAll","currentAnchor","Array","from","includes","scrollTop","getBoundingClientRect","top","currentAnchorTop","nextAnchor","resetScroll","isScrollTopJustUpdated","handleScroll","listLength","offsetHeight","isNearTop","offsetTop","isNearBottom","isUpdated","nextAnchorTop","newAnchorTop","offsetParent","teactFastList","IS_ANDROID","dialogRef","hasCloseButton","noBackdrop","shouldSkipHistoryAnimations","shouldRender","modalRef","captureKeyboardListeners","onEsc","element","handleKeyDown","key","preventDefault","stopPropagation","focusableElements","currentFocusedIndex","findIndex","em","isSameNode","document","activeElement","newFocusedIndex","shiftKey","focus","addEventListener","removeEventListener","trapFocus","forceClose","useHistoryBack","useEffectWithPrevDeps","prevIsOpen","body","classList","toggle","dispatchHeavyAnimationEvent","remove","Portal","tabIndex","role","Button","round","ariaLabel","containerId","elementRef","createElement","querySelector","add","appendChild","TeactDOM","removeChild","onBlur","onFocus","hasFocus","useCurrentOrPrev","shouldSkipUndefined","shouldForceCurrent","prev","usePrevious","getViewportSlice","sourceIds","listSlice","offsetId","index","indexOf","indexForDirection","Math","max","to","newViewportIds","slice","areSomeLocal","areAllLocal","listIds","isDisabled","forceFullPreload","lastParamsRef","viewportIdsRef","forceUpdate","useForceUpdate","prevListIds","prevIsDisabled","areSortedArraysEqual","viewportIds","getMore","mediaHash","noLoad","mediaFormat","delay","mediaData","startedAt","Date","now","spentTime","CLIPBOARD_ITEM_SUPPORTED","navigator","clipboard","ClipboardItem","textCopyEl","setAttribute","copyTextToClipboard","str","value","selection","getSelection","rangeToRestore","rangeCount","getRangeAt","select","execCommand","removeAllRanges","addRange","copyImageToClipboard","imageUrl","canvas","ctx","getContext","imageEl","Image","onload","currentTarget","img","width","height","drawImage","toBlob","copyBlobToClipboard","pngBlob","write","type","error","DEBUG","console","prevGlobal","foldersById","chatsById","usersById","notifySettings","notifyExceptions","prepared","folderSummariesById","chatSummariesById","Map","folderIdsByChatId","chatIdsByFolderId","isOrderedListJustPatched","results","orderedIdsByFolderId","chatsCountByFolderId","unreadCountersByFolderId","callbacks","createCallbackManager","updateFolderManagerThrottled","throttle","onIdle","updateFolderManager","getGlobal","init","addCallback","getOrderedIds","folderId","getChatsCount","getUnreadCounters","getAllNotificationsCount","ALL_FOLDER_ID","notificationsCount","getPinnedChatsCount","pinnedChatIds","addOrderedIdsCallback","callback","addChatsCountCallback","addUnreadCountersCallback","global","DEBUG_startedAt","performance","isAllFolderChanged","chats","active","isMainFolderChanged","orderedPinnedIds","isArchivedFolderChanged","archived","ARCHIVED_FOLDER_ID","areFoldersChanged","chatFolders","byId","areChatsChanged","areUsersChanged","users","areNotifySettingsChanged","selectNotifySettings","areNotifyExceptionsChanged","selectNotifyExceptions","prevAllFolderListIds","allFolderListIds","prevArchivedFolderListIds","archivedFolderListIds","changedFolders","newListIds","newPinnedIds","buildFolderSummaryFromMainList","allFolderPinnedIds","push","archivedFolderPinnedIds","newFoldersById","Object","values","forEach","folder","excludedChatIds","Set","includedChatIds","buildFolderSummary","updateFolders","affectedFolderIds","newChatsById","newUsersById","newNotifySettings","newNotifyExceptions","folderSummaries","newAllFolderListIds","newArchivedFolderListIds","allIds","unique","concat","chatId","newFolderIds","currentSummary","get","newSummary","lastMessage","isRestricted","isNotJoined","unreadCount","unreadMentionsCount","hasUnreadMark","joinDate","draftDate","userInfo","isListed","isArchived","isMuted","selectIsChatMuted","isUnread","order","date","isUserBot","isUserContact","isContact","buildChatSummary","arePropsShallowEqual","set","chatSummary","reduce","acc","folderSummary","has","excludeArchived","excludeRead","excludeMuted","bots","contacts","nonContacts","channels","groups","isChatInFolder","sort","buildChatFolderIds","delete","currentFolderIds","deletedFolderIds","currentFolderIdsSet","newFolderIdsSet","currentFolderOrderedIds","filter","updateListsForChat","updateChats","wasUnreadCountersChanged","wasChatsCountChanged","newOrderedIds","chatIds","prevOrderedIds","allListIds","chatId1","chatId2","buildFolderOrderedIds","currentOrderedIds","runCallbacks","currentChatsCount","newChatsCount","currentUnreadCounters","newUnreadCounters","orderedIds","chatsCount","buildFolderUnreadCounters","newValue","updateResults","duration","warn","currentListIds","currentPinnedIds","forceReflow","offsetWidth","patchChromiumScroll","display","IS_IOS","overflow","mediaEl","catch","err"],"sourceRoot":""}