{"version":3,"file":"1989.f3ae588c2fcab851759e.js","mappings":"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","sources":["webpack://telegram-t/./src/components/common/Avatar.tsx","webpack://telegram-t/./src/components/middle/message/hooks/useVideoAutoPause.ts","webpack://telegram-t/./src/components/ui/InfiniteScroll.tsx","webpack://telegram-t/./src/components/ui/Modal.tsx","webpack://telegram-t/./src/util/trapFocus.ts","webpack://telegram-t/./src/components/ui/Portal.ts","webpack://telegram-t/./src/global/selectors/limits.ts","webpack://telegram-t/./src/hooks/useInfiniteScroll.ts","webpack://telegram-t/./src/hooks/useIntersectionObserver.ts","webpack://telegram-t/./src/hooks/useInterval.ts","webpack://telegram-t/./src/hooks/useMedia.ts","webpack://telegram-t/./src/util/resetScroll.ts","webpack://telegram-t/./src/util/safePlay.ts"],"sourcesContent":["import type { MouseEvent as ReactMouseEvent } from 'react';\nimport React, {\n  memo, useCallback, useEffect, useRef,\n} from '../../lib/teact/teact';\nimport { getActions } from '../../global';\n\nimport type { FC, TeactNode } from '../../lib/teact/teact';\nimport type {\n  ApiChat, ApiPhoto, ApiUser, ApiUserStatus,\n} from '../../api/types';\nimport type { ObserveFn } from '../../hooks/useIntersectionObserver';\nimport { ApiMediaFormat } from '../../api/types';\n\nimport { IS_TEST } from '../../config';\nimport {\n  getChatAvatarHash,\n  getChatTitle,\n  getUserColorKey,\n  getUserFullName,\n  isUserId,\n  isChatWithRepliesBot,\n  isDeletedUser,\n  isUserOnline,\n} from '../../global/helpers';\nimport { getFirstLetters } from '../../util/textFormat';\nimport buildClassName, { createClassNameBuilder } from '../../util/buildClassName';\nimport renderText from './helpers/renderText';\n\nimport useMedia from '../../hooks/useMedia';\nimport useShowTransition from '../../hooks/useShowTransition';\nimport useLang from '../../hooks/useLang';\nimport { useIsIntersecting } from '../../hooks/useIntersectionObserver';\n\nimport './Avatar.scss';\nimport useVideoAutoPause from '../middle/message/hooks/useVideoAutoPause';\n\nconst cn = createClassNameBuilder('Avatar');\ncn.media = cn('media');\ncn.icon = cn('icon');\n\ntype OwnProps = {\n  className?: string;\n  size?: 'micro' | 'tiny' | 'small' | 'medium' | 'large' | 'jumbo';\n  chat?: ApiChat;\n  user?: ApiUser;\n  photo?: ApiPhoto;\n  userStatus?: ApiUserStatus;\n  text?: string;\n  isSavedMessages?: boolean;\n  noVideo?: boolean;\n  noLoop?: boolean;\n  lastSyncTime?: number;\n  observeIntersection?: ObserveFn;\n  onClick?: (e: ReactMouseEvent<HTMLDivElement, MouseEvent>, hasMedia: boolean) => void;\n};\n\nconst Avatar: FC<OwnProps> = ({\n  className,\n  size = 'large',\n  chat,\n  user,\n  photo,\n  userStatus,\n  text,\n  isSavedMessages,\n  noVideo,\n  noLoop,\n  lastSyncTime,\n  observeIntersection,\n  onClick,\n}) => {\n  const { loadFullUser } = getActions();\n  // eslint-disable-next-line no-null/no-null\n  const ref = useRef<HTMLDivElement>(null);\n  // eslint-disable-next-line no-null/no-null\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const isIntersecting = useIsIntersecting(ref, observeIntersection);\n  const isDeleted = user && isDeletedUser(user);\n  const isReplies = user && isChatWithRepliesBot(user.id);\n  let imageHash: string | undefined;\n  let videoHash: string | undefined;\n\n  const hasVideoAvatar = (user || chat)?.hasVideoAvatar;\n  const profilePhoto = (user?.fullInfo?.profilePhoto || chat?.fullInfo?.profilePhoto);\n  const shouldShowVideo = !noVideo && Boolean(user?.isPremium && profilePhoto?.isVideo);\n  const shouldPlayVideo = isIntersecting && shouldShowVideo;\n\n  const shouldFetchBig = size === 'jumbo';\n  if (!isSavedMessages && !isDeleted) {\n    if (shouldShowVideo) {\n      videoHash = getChatAvatarHash(user!, undefined, 'video');\n    }\n    if (user) {\n      imageHash = getChatAvatarHash(user, shouldFetchBig ? 'big' : undefined);\n    } else if (chat) {\n      imageHash = getChatAvatarHash(chat, shouldFetchBig ? 'big' : undefined);\n    } else if (photo) {\n      imageHash = `photo${photo.id}?size=m`;\n    }\n  }\n\n  useVideoAutoPause(videoRef, shouldPlayVideo);\n\n  useEffect(() => {\n    const video = videoRef.current;\n    if (!video || !noLoop) return undefined;\n\n    const returnToStart = () => {\n      video.currentTime = 0;\n    };\n\n    video.addEventListener('ended', returnToStart);\n    return () => video.removeEventListener('ended', returnToStart);\n  }, [noLoop]);\n\n  useEffect(() => {\n    if (isIntersecting && !noVideo && user && hasVideoAvatar && !profilePhoto) {\n      loadFullUser({ userId: user.id });\n    }\n  }, [hasVideoAvatar, profilePhoto, loadFullUser, user, noVideo, isIntersecting]);\n\n  const imgBlobUrl = useMedia(imageHash, false, ApiMediaFormat.BlobUrl, lastSyncTime);\n  const videoBlobUrl = useMedia(videoHash, false, ApiMediaFormat.BlobUrl, lastSyncTime);\n  const hasBlobUrl = Boolean(imgBlobUrl || videoBlobUrl);\n  const { transitionClassNames } = useShowTransition(hasBlobUrl, undefined, hasBlobUrl, 'slow');\n\n  const lang = useLang();\n\n  let content: TeactNode | undefined;\n  const author = user ? getUserFullName(user) : (chat ? getChatTitle(lang, chat) : text);\n\n  if (isSavedMessages) {\n    content = <i className={buildClassName(cn.icon, 'icon-avatar-saved-messages')} aria-label={author} />;\n  } else if (isDeleted) {\n    content = <i className={buildClassName(cn.icon, 'icon-avatar-deleted-account')} aria-label={author} />;\n  } else if (isReplies) {\n    content = <i className={buildClassName(cn.icon, 'icon-reply-filled')} aria-label={author} />;\n  } else if (hasBlobUrl) {\n    content = (\n      <>\n        <img\n          src={imgBlobUrl}\n          className={buildClassName(cn.media, 'avatar-media', transitionClassNames, videoBlobUrl && 'poster')}\n          alt={author}\n          decoding=\"async\"\n        />\n        {videoBlobUrl && (\n          <video\n            ref={videoRef}\n            src={videoBlobUrl}\n            className={buildClassName(cn.media, 'avatar-media', transitionClassNames)}\n            muted\n            autoPlay\n            disablePictureInPicture\n            loop={!noLoop}\n            playsInline\n          />\n        )}\n      </>\n    );\n  } else if (user) {\n    const userFullName = getUserFullName(user);\n    content = userFullName ? getFirstLetters(userFullName, 2) : undefined;\n  } else if (chat) {\n    const title = getChatTitle(lang, chat);\n    content = title && getFirstLetters(title, isUserId(chat.id) ? 2 : 1);\n  } else if (text) {\n    content = getFirstLetters(text, 2);\n  }\n\n  const isOnline = !isSavedMessages && user && userStatus && isUserOnline(user, userStatus);\n  const fullClassName = buildClassName(\n    `Avatar size-${size}`,\n    className,\n    `color-bg-${getUserColorKey(user || chat)}`,\n    isSavedMessages && 'saved-messages',\n    isDeleted && 'deleted-account',\n    isReplies && 'replies-bot-account',\n    isOnline && 'online',\n    onClick && 'interactive',\n    (!isSavedMessages && !imgBlobUrl) && 'no-photo',\n  );\n\n  const hasMedia = Boolean(isSavedMessages || imgBlobUrl);\n  const handleClick = useCallback((e: ReactMouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (onClick) {\n      onClick(e, hasMedia);\n    }\n  }, [onClick, hasMedia]);\n\n  const senderId = (user || chat) && (user || chat)!.id;\n\n  return (\n    <div\n      ref={ref}\n      className={fullClassName}\n      onClick={handleClick}\n      data-test-sender-id={IS_TEST ? senderId : undefined}\n      aria-label={typeof content === 'string' ? author : undefined}\n    >\n      {typeof content === 'string' ? renderText(content, [size === 'jumbo' ? 'hq_emoji' : 'emoji']) : content}\n    </div>\n  );\n};\n\nexport default memo(Avatar);\n","import { useCallback, useRef } from '../../../../lib/teact/teact';\n\nimport { fastRaf } from '../../../../util/schedulers';\nimport safePlay from '../../../../util/safePlay';\nimport useBackgroundMode from '../../../../hooks/useBackgroundMode';\nimport useHeavyAnimationCheck from '../../../../hooks/useHeavyAnimationCheck';\n\nexport default function useVideoAutoPause(playerRef: { current: HTMLVideoElement | null }, canPlay: boolean) {\n  const wasPlaying = useRef(playerRef.current?.paused);\n  const canPlayRef = useRef();\n  canPlayRef.current = canPlay;\n\n  const freezePlaying = useCallback(() => {\n    if (!playerRef.current) {\n      return;\n    }\n\n    wasPlaying.current = !playerRef.current.paused;\n\n    if (wasPlaying.current) {\n      playerRef.current.pause();\n    }\n  }, [playerRef]);\n\n  const unfreezePlaying = useCallback(() => {\n    if (\n      playerRef.current && wasPlaying.current && canPlayRef.current\n      // At this point HTMLVideoElement can be unmounted from the DOM\n      && document.body.contains(playerRef.current)\n    ) {\n      safePlay(playerRef.current);\n    }\n  }, [playerRef]);\n\n  const unfreezePlayingOnRaf = useCallback(() => {\n    fastRaf(unfreezePlaying);\n  }, [unfreezePlaying]);\n\n  useBackgroundMode(freezePlaying, unfreezePlayingOnRaf);\n  useHeavyAnimationCheck(freezePlaying, unfreezePlaying);\n}\n","import type { RefObject, UIEvent } from 'react';\nimport { LoadMoreDirection } from '../../types';\n\nimport type { FC } from '../../lib/teact/teact';\nimport React, {\n  useCallback, useEffect, useLayoutEffect, useMemo, useRef,\n} from '../../lib/teact/teact';\n\nimport { debounce } from '../../util/schedulers';\nimport resetScroll from '../../util/resetScroll';\nimport { IS_ANDROID } from '../../util/environment';\nimport buildStyle from '../../util/buildStyle';\n\ntype OwnProps = {\n  ref?: RefObject<HTMLDivElement>;\n  className?: string;\n  items?: any[];\n  itemSelector?: string;\n  preloadBackwards?: number;\n  sensitiveArea?: number;\n  withAbsolutePositioning?: boolean;\n  maxHeight?: number;\n  noScrollRestore?: boolean;\n  noScrollRestoreOnTop?: boolean;\n  noFastList?: boolean;\n  cacheBuster?: any;\n  children: React.ReactNode;\n  onLoadMore?: ({ direction }: { direction: LoadMoreDirection; noScroll?: boolean }) => void;\n  onScroll?: (e: UIEvent<HTMLDivElement>) => void;\n  onKeyDown?: (e: React.KeyboardEvent<any>) => void;\n  onDragOver?: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragLeave?: (e: React.DragEvent<HTMLDivElement>) => void;\n};\n\nconst DEFAULT_LIST_SELECTOR = '.ListItem';\nconst DEFAULT_PRELOAD_BACKWARDS = 20;\nconst DEFAULT_SENSITIVE_AREA = 800;\n\nconst InfiniteScroll: FC<OwnProps> = ({\n  ref,\n  className,\n  items,\n  itemSelector = DEFAULT_LIST_SELECTOR,\n  preloadBackwards = DEFAULT_PRELOAD_BACKWARDS,\n  sensitiveArea = DEFAULT_SENSITIVE_AREA,\n  withAbsolutePositioning,\n  maxHeight,\n  // Used to turn off restoring scroll position (e.g. for frequently re-ordered chat or user lists)\n  noScrollRestore = false,\n  noScrollRestoreOnTop = false,\n  noFastList,\n  // Used to re-query `listItemElements` if rendering is delayed by transition\n  cacheBuster,\n  children,\n  onLoadMore,\n  onScroll,\n  onKeyDown,\n  onDragOver,\n  onDragLeave,\n}: OwnProps) => {\n  // eslint-disable-next-line no-null/no-null\n  let containerRef = useRef<HTMLDivElement>(null);\n  if (ref) {\n    containerRef = ref;\n  }\n\n  const stateRef = useRef<{\n    listItemElements?: NodeListOf<HTMLDivElement>;\n    isScrollTopJustUpdated?: boolean;\n    currentAnchor?: HTMLDivElement | undefined;\n    currentAnchorTop?: number;\n  }>({});\n\n  const [loadMoreBackwards, loadMoreForwards] = useMemo(() => {\n    if (!onLoadMore) {\n      return [];\n    }\n\n    return [\n      debounce((noScroll = false) => {\n        onLoadMore({ direction: LoadMoreDirection.Backwards, noScroll });\n      }, 1000, true, false),\n      debounce(() => {\n        onLoadMore({ direction: LoadMoreDirection.Forwards });\n      }, 1000, true, false),\n    ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [onLoadMore, items]);\n\n  // Initial preload\n  useEffect(() => {\n    if (!loadMoreBackwards) {\n      return;\n    }\n\n    if (preloadBackwards > 0 && (!items || items.length < preloadBackwards)) {\n      loadMoreBackwards(true);\n      return;\n    }\n\n    const { scrollHeight, clientHeight } = containerRef.current!;\n    if (clientHeight && scrollHeight <= clientHeight) {\n      loadMoreBackwards();\n    }\n  }, [items, loadMoreBackwards, preloadBackwards]);\n\n  // Restore `scrollTop` after adding items\n  useLayoutEffect(() => {\n    const container = containerRef.current!;\n    const state = stateRef.current;\n\n    state.listItemElements = container.querySelectorAll<HTMLDivElement>(itemSelector);\n\n    let newScrollTop;\n\n    if (state.currentAnchor && Array.from(state.listItemElements).includes(state.currentAnchor)) {\n      const { scrollTop } = container;\n      const newAnchorTop = state.currentAnchor.getBoundingClientRect().top;\n      newScrollTop = scrollTop + (newAnchorTop - state.currentAnchorTop!);\n    } else {\n      const nextAnchor = state.listItemElements[0];\n      if (nextAnchor) {\n        state.currentAnchor = nextAnchor;\n        state.currentAnchorTop = nextAnchor.getBoundingClientRect().top;\n      }\n    }\n\n    if (withAbsolutePositioning || noScrollRestore) {\n      return;\n    }\n\n    if (noScrollRestoreOnTop && container.scrollTop === 0) {\n      return;\n    }\n\n    resetScroll(container, newScrollTop);\n\n    state.isScrollTopJustUpdated = true;\n  }, [items, itemSelector, noScrollRestore, noScrollRestoreOnTop, cacheBuster, withAbsolutePositioning]);\n\n  const handleScroll = useCallback((e: UIEvent<HTMLDivElement>) => {\n    if (loadMoreForwards && loadMoreBackwards) {\n      const {\n        isScrollTopJustUpdated, currentAnchor, currentAnchorTop,\n      } = stateRef.current;\n      const listItemElements = stateRef.current.listItemElements!;\n\n      if (isScrollTopJustUpdated) {\n        stateRef.current.isScrollTopJustUpdated = false;\n        return;\n      }\n\n      const listLength = listItemElements.length;\n      const container = containerRef.current!;\n      const { scrollTop, scrollHeight, offsetHeight } = container;\n      const top = listLength ? listItemElements[0].offsetTop : 0;\n      const isNearTop = scrollTop <= top + sensitiveArea;\n      const bottom = listLength\n        ? listItemElements[listLength - 1].offsetTop + listItemElements[listLength - 1].offsetHeight\n        : scrollHeight;\n      const isNearBottom = bottom - (scrollTop + offsetHeight) <= sensitiveArea;\n      let isUpdated = false;\n\n      if (isNearTop) {\n        const nextAnchor = listItemElements[0];\n        if (nextAnchor) {\n          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;\n          const newAnchorTop = currentAnchor?.offsetParent && currentAnchor !== nextAnchor\n            ? currentAnchor.getBoundingClientRect().top\n            : nextAnchorTop;\n          const isMovingUp = (\n            currentAnchor && currentAnchorTop !== undefined && newAnchorTop > currentAnchorTop\n          );\n\n          if (isMovingUp) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchorTop;\n            isUpdated = true;\n            loadMoreForwards();\n          }\n        }\n      }\n\n      if (isNearBottom) {\n        const nextAnchor = listItemElements[listLength - 1];\n        if (nextAnchor) {\n          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;\n          const newAnchorTop = currentAnchor?.offsetParent && currentAnchor !== nextAnchor\n            ? currentAnchor.getBoundingClientRect().top\n            : nextAnchorTop;\n          const isMovingDown = (\n            currentAnchor && currentAnchorTop !== undefined && newAnchorTop < currentAnchorTop\n          );\n\n          if (isMovingDown) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchorTop;\n            isUpdated = true;\n            loadMoreBackwards();\n          }\n        }\n      }\n\n      if (!isUpdated) {\n        if (currentAnchor?.offsetParent) {\n          stateRef.current.currentAnchorTop = currentAnchor.getBoundingClientRect().top;\n        } else {\n          const nextAnchor = listItemElements[0];\n\n          if (nextAnchor) {\n            stateRef.current.currentAnchor = nextAnchor;\n            stateRef.current.currentAnchorTop = nextAnchor.getBoundingClientRect().top;\n          }\n        }\n      }\n    }\n\n    if (onScroll) {\n      onScroll(e);\n    }\n  }, [loadMoreBackwards, loadMoreForwards, onScroll, sensitiveArea]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={className}\n      onScroll={handleScroll}\n      teactFastList={!noFastList && !withAbsolutePositioning}\n      onKeyDown={onKeyDown}\n      onDragOver={onDragOver}\n      onDragLeave={onDragLeave}\n    >\n      {withAbsolutePositioning && items?.length ? (\n        <div\n          teactFastList={!noFastList}\n          style={buildStyle('position: relative', IS_ANDROID && `height: ${maxHeight}px`)}\n        >\n          {children}\n        </div>\n      ) : children}\n    </div>\n  );\n};\n\nexport default InfiniteScroll;\n","import type { RefObject } from 'react';\nimport type { FC, TeactNode } from '../../lib/teact/teact';\nimport React, { useEffect, useRef } from '../../lib/teact/teact';\n\nimport type { TextPart } from '../../types';\n\nimport captureKeyboardListeners from '../../util/captureKeyboardListeners';\nimport trapFocus from '../../util/trapFocus';\nimport buildClassName from '../../util/buildClassName';\nimport { dispatchHeavyAnimationEvent } from '../../hooks/useHeavyAnimationCheck';\nimport useShowTransition from '../../hooks/useShowTransition';\nimport useEffectWithPrevDeps from '../../hooks/useEffectWithPrevDeps';\nimport useLang from '../../hooks/useLang';\nimport useHistoryBack from '../../hooks/useHistoryBack';\n\nimport Button from './Button';\nimport Portal from './Portal';\n\nimport './Modal.scss';\n\nconst ANIMATION_DURATION = 200;\n\ntype OwnProps = {\n  title?: string | TextPart[];\n  className?: string;\n  isOpen?: boolean;\n  header?: TeactNode;\n  hasCloseButton?: boolean;\n  noBackdrop?: boolean;\n  children: React.ReactNode;\n  style?: string;\n  onClose: () => void;\n  onCloseAnimationEnd?: () => void;\n  onEnter?: () => void;\n  dialogRef?: RefObject<HTMLDivElement>;\n};\n\ntype StateProps = {\n  shouldSkipHistoryAnimations?: boolean;\n};\n\nconst Modal: FC<OwnProps & StateProps> = ({\n  dialogRef,\n  title,\n  className,\n  isOpen,\n  header,\n  hasCloseButton,\n  noBackdrop,\n  children,\n  style,\n  onClose,\n  onCloseAnimationEnd,\n  onEnter,\n  shouldSkipHistoryAnimations,\n}) => {\n  const {\n    shouldRender,\n    transitionClassNames,\n  } = useShowTransition(\n    isOpen, onCloseAnimationEnd, shouldSkipHistoryAnimations, undefined, shouldSkipHistoryAnimations,\n  );\n  // eslint-disable-next-line no-null/no-null\n  const modalRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => (isOpen\n    ? captureKeyboardListeners({ onEsc: onClose, onEnter })\n    : undefined), [isOpen, onClose, onEnter]);\n  useEffect(() => (isOpen && modalRef.current ? trapFocus(modalRef.current) : undefined), [isOpen]);\n\n  useHistoryBack({\n    isActive: isOpen,\n    onBack: onClose,\n  });\n\n  useEffectWithPrevDeps(([prevIsOpen]) => {\n    document.body.classList.toggle('has-open-dialog', isOpen);\n    if (isOpen || (!isOpen && prevIsOpen !== undefined)) {\n      dispatchHeavyAnimationEvent(ANIMATION_DURATION);\n    }\n\n    return () => {\n      document.body.classList.remove('has-open-dialog');\n    };\n  }, [isOpen]);\n\n  const lang = useLang();\n\n  if (!shouldRender) {\n    return undefined;\n  }\n\n  function renderHeader() {\n    if (header) {\n      return header;\n    }\n\n    if (!title) {\n      return undefined;\n    }\n\n    return (\n      <div className=\"modal-header\">\n        {hasCloseButton && (\n          <Button\n            round\n            color=\"translucent\"\n            size=\"smaller\"\n            ariaLabel={lang('Close')}\n            onClick={onClose}\n          >\n            <i className=\"icon-close\" />\n          </Button>\n        )}\n        <div className=\"modal-title\">{title}</div>\n      </div>\n    );\n  }\n\n  const fullClassName = buildClassName(\n    'Modal',\n    className,\n    transitionClassNames,\n    noBackdrop && 'transparent-backdrop',\n  );\n\n  return (\n    <Portal>\n      <div\n        ref={modalRef}\n        className={fullClassName}\n        tabIndex={-1}\n        role=\"dialog\"\n      >\n        <div className=\"modal-container\">\n          <div className=\"modal-backdrop\" onClick={onClose} />\n          <div className=\"modal-dialog\" ref={dialogRef}>\n            {renderHeader()}\n            <div className=\"modal-content custom-scroll\" style={style}>\n              {children}\n            </div>\n          </div>\n        </div>\n      </div>\n    </Portal>\n  );\n};\n\nexport default Modal;\n","export default function trapFocus(element: HTMLElement) {\n  function handleKeyDown(e: KeyboardEvent) {\n    if (e.key !== 'Tab') {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const focusableElements = Array.from(\n      element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'),\n    ) as HTMLElement[];\n    if (!focusableElements.length) {\n      return;\n    }\n\n    const currentFocusedIndex = focusableElements.findIndex((em) => em.isSameNode(document.activeElement));\n    let newFocusedIndex = 0;\n    if (currentFocusedIndex >= 0) {\n      if (e.shiftKey) {\n        newFocusedIndex = currentFocusedIndex > 0\n          ? currentFocusedIndex - 1\n          : focusableElements.length - 1;\n      } else {\n        newFocusedIndex = currentFocusedIndex < focusableElements.length - 1\n          ? currentFocusedIndex + 1\n          : 0;\n      }\n    }\n\n    focusableElements[newFocusedIndex].focus();\n  }\n\n  document.addEventListener('keydown', handleKeyDown, false);\n\n  return () => {\n    document.removeEventListener('keydown', handleKeyDown, false);\n  };\n}\n","import type { FC, VirtualElement } from '../../lib/teact/teact';\nimport { useRef, useLayoutEffect } from '../../lib/teact/teact';\nimport TeactDOM from '../../lib/teact/teact-dom';\n\ntype OwnProps = {\n  containerId?: string;\n  className?: string;\n  children: VirtualElement;\n};\n\nconst Portal: FC<OwnProps> = ({ containerId, className, children }) => {\n  const elementRef = useRef<HTMLDivElement>();\n  if (!elementRef.current) {\n    elementRef.current = document.createElement('div');\n  }\n\n  useLayoutEffect(() => {\n    const container = document.querySelector<HTMLDivElement>(containerId || '#portals');\n    if (!container) {\n      return undefined;\n    }\n\n    const element = elementRef.current!;\n    if (className) {\n      element.classList.add(className);\n    }\n\n    container.appendChild(element);\n\n    return () => {\n      TeactDOM.render(undefined, element);\n      container.removeChild(element);\n    };\n  }, [className, containerId]);\n\n  return TeactDOM.render(children, elementRef.current);\n};\n\nexport default Portal;\n","import type { ApiLimitType, GlobalState } from '../types';\nimport { selectIsCurrentUserPremium } from './users';\nimport { DEFAULT_LIMITS } from '../../config';\n\nexport function selectCurrentLimit(global: GlobalState, limit: ApiLimitType) {\n  const { appConfig } = global;\n  if (!appConfig) {\n    return DEFAULT_LIMITS[limit][0];\n  }\n\n  const isPremium = selectIsCurrentUserPremium(global);\n  const { limits } = appConfig;\n\n  const value = limits[limit][isPremium ? 1 : 0] ?? DEFAULT_LIMITS[limit][isPremium ? 1 : 0];\n  if (limit === 'dialogFilters') return value + 1; // Server does not count \"All\" as folder, but we need to\n  return value;\n}\n\nexport function selectPremiumLimit(global: GlobalState, limit: ApiLimitType) {\n  const { appConfig } = global;\n  if (!appConfig) return DEFAULT_LIMITS[limit][1];\n\n  const { limits } = appConfig;\n\n  return limits[limit][1];\n}\n","import { useCallback, useRef } from '../lib/teact/teact';\nimport { LoadMoreDirection } from '../types';\n\nimport { areSortedArraysEqual } from '../util/iteratees';\nimport useForceUpdate from './useForceUpdate';\nimport usePrevious from './usePrevious';\n\ntype GetMore = (args: { direction: LoadMoreDirection }) => void;\ntype LoadMoreBackwards = (args: { offsetId?: string | number }) => void;\n\nconst DEFAULT_LIST_SLICE = 30;\n\nconst useInfiniteScroll = <ListId extends string | number>(\n  loadMoreBackwards?: LoadMoreBackwards,\n  listIds?: ListId[],\n  isDisabled = false,\n  listSlice = DEFAULT_LIST_SLICE,\n): [ListId[]?, GetMore?] => {\n  const lastParamsRef = useRef<{\n    direction?: LoadMoreDirection;\n    offsetId?: ListId;\n  }>();\n\n  const viewportIdsRef = useRef<ListId[] | undefined>((() => {\n    // Only run once to initialize\n    if (!listIds || lastParamsRef.current) {\n      return undefined;\n    }\n\n    const { newViewportIds } = getViewportSlice(listIds, LoadMoreDirection.Forwards, listSlice, listIds[0]);\n    return newViewportIds;\n  })());\n\n  const forceUpdate = useForceUpdate();\n\n  if (isDisabled) {\n    lastParamsRef.current = {};\n  }\n\n  const prevListIds = usePrevious(listIds);\n  const prevIsDisabled = usePrevious(isDisabled);\n  if (listIds && !isDisabled && (listIds !== prevListIds || isDisabled !== prevIsDisabled)) {\n    const { offsetId = listIds[0], direction = LoadMoreDirection.Forwards } = lastParamsRef.current || {};\n    const { newViewportIds } = getViewportSlice(listIds, direction, listSlice, offsetId);\n\n    if (!viewportIdsRef.current || !areSortedArraysEqual(viewportIdsRef.current, newViewportIds)) {\n      viewportIdsRef.current = newViewportIds;\n    }\n  } else if (!listIds) {\n    viewportIdsRef.current = undefined;\n  }\n\n  const getMore: GetMore = useCallback(({\n    direction,\n    noScroll,\n  }: { direction: LoadMoreDirection; noScroll?: boolean }) => {\n    const viewportIds = viewportIdsRef.current;\n\n    const offsetId = viewportIds\n      ? direction === LoadMoreDirection.Backwards ? viewportIds[viewportIds.length - 1] : viewportIds[0]\n      : undefined;\n\n    if (!listIds) {\n      if (loadMoreBackwards) {\n        loadMoreBackwards({ offsetId });\n      }\n\n      return;\n    }\n\n    if (!noScroll) {\n      lastParamsRef.current = { ...lastParamsRef.current, direction, offsetId };\n    }\n\n    const {\n      newViewportIds, areSomeLocal, areAllLocal,\n    } = getViewportSlice(listIds, direction, listSlice, offsetId);\n\n    if (areSomeLocal && !(viewportIds && areSortedArraysEqual(viewportIds, newViewportIds))) {\n      viewportIdsRef.current = newViewportIds;\n      forceUpdate();\n    }\n\n    if (!areAllLocal && loadMoreBackwards) {\n      loadMoreBackwards({ offsetId });\n    }\n  }, [listIds, listSlice, loadMoreBackwards, forceUpdate]);\n\n  return isDisabled ? [listIds] : [viewportIdsRef.current, getMore];\n};\n\nfunction getViewportSlice<ListId extends string | number>(\n  sourceIds: ListId[],\n  direction: LoadMoreDirection,\n  listSlice: number,\n  offsetId?: ListId,\n) {\n  const { length } = sourceIds;\n  const index = offsetId ? sourceIds.indexOf(offsetId) : 0;\n  const isForwards = direction === LoadMoreDirection.Forwards;\n  const indexForDirection = isForwards ? index : (index + 1) || length;\n  const from = Math.max(0, indexForDirection - listSlice);\n  const to = indexForDirection + listSlice - 1;\n  const newViewportIds = sourceIds.slice(Math.max(0, from), to + 1);\n\n  let areSomeLocal;\n  let areAllLocal;\n  switch (direction) {\n    case LoadMoreDirection.Forwards:\n      areSomeLocal = indexForDirection > 0;\n      areAllLocal = from >= 0;\n      break;\n    case LoadMoreDirection.Backwards:\n      areSomeLocal = indexForDirection < length;\n      areAllLocal = to <= length - 1;\n      break;\n  }\n\n  return { newViewportIds, areSomeLocal, areAllLocal };\n}\n\nexport default useInfiniteScroll;\n","import type { RefObject } from 'react';\nimport {\n  useEffect, useRef, useCallback, useState,\n} from '../lib/teact/teact';\n\nimport { throttle, debounce } from '../util/schedulers';\nimport useHeavyAnimationCheck from './useHeavyAnimationCheck';\n\ntype TargetCallback = (entry: IntersectionObserverEntry) => void;\ntype RootCallback = (entries: IntersectionObserverEntry[]) => void;\ntype ObserveCleanup = NoneToVoidFunction;\nexport type ObserveFn = (target: HTMLElement, targetCallback?: TargetCallback) => ObserveCleanup;\n\ninterface IntersectionController {\n  observer: IntersectionObserver;\n  callbacks: Map<HTMLElement, TargetCallback>;\n}\n\ninterface Response {\n  observe: ObserveFn;\n  freeze: NoneToVoidFunction;\n  unfreeze: NoneToVoidFunction;\n}\n\nexport function useIntersectionObserver({\n  rootRef,\n  throttleMs,\n  debounceMs,\n  shouldSkipFirst,\n  margin,\n  threshold,\n  isDisabled,\n}: {\n  rootRef: RefObject<HTMLDivElement>;\n  throttleMs?: number;\n  debounceMs?: number;\n  shouldSkipFirst?: boolean;\n  margin?: number;\n  threshold?: number | number[];\n  isDisabled?: boolean;\n}, rootCallback?: RootCallback): Response {\n  const controllerRef = useRef<IntersectionController>();\n  const rootCallbackRef = useRef<RootCallback>();\n  const freezeFlagsRef = useRef(0);\n  const onUnfreezeRef = useRef<NoneToVoidFunction>();\n\n  rootCallbackRef.current = rootCallback;\n\n  const freeze = useCallback(() => {\n    freezeFlagsRef.current++;\n  }, []);\n\n  const unfreeze = useCallback(() => {\n    if (!freezeFlagsRef.current) {\n      return;\n    }\n\n    freezeFlagsRef.current--;\n\n    if (!freezeFlagsRef.current && onUnfreezeRef.current) {\n      onUnfreezeRef.current();\n      onUnfreezeRef.current = undefined;\n    }\n  }, []);\n\n  useHeavyAnimationCheck(freeze, unfreeze);\n\n  useEffect(() => {\n    if (isDisabled) {\n      return undefined;\n    }\n\n    return () => {\n      if (controllerRef.current) {\n        controllerRef.current.observer.disconnect();\n        controllerRef.current.callbacks.clear();\n        controllerRef.current = undefined;\n      }\n    };\n  }, [isDisabled]);\n\n  function initController() {\n    const callbacks = new Map();\n    const entriesAccumulator = new Map<Element, IntersectionObserverEntry>();\n    const observerCallbackSync = () => {\n      const entries = Array.from(entriesAccumulator.values());\n\n      entries.forEach((entry: IntersectionObserverEntry) => {\n        const callback = callbacks.get(entry.target);\n        if (callback) {\n          callback!(entry, entries);\n        }\n      });\n\n      if (rootCallbackRef.current) {\n        rootCallbackRef.current(entries);\n      }\n\n      entriesAccumulator.clear();\n    };\n    const scheduler = throttleMs ? throttle : debounceMs ? debounce : undefined;\n    const observerCallback = scheduler\n      ? scheduler(observerCallbackSync, (throttleMs || debounceMs)!, !shouldSkipFirst)\n      : observerCallbackSync;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          entriesAccumulator.set(entry.target, entry);\n        });\n\n        if (freezeFlagsRef.current) {\n          onUnfreezeRef.current = () => {\n            observerCallback();\n          };\n        } else {\n          observerCallback();\n        }\n      },\n      {\n        root: rootRef.current,\n        rootMargin: margin ? `${margin}px` : undefined,\n        threshold,\n      },\n    );\n\n    controllerRef.current = { observer, callbacks };\n  }\n\n  const observe = useCallback((target, targetCallback) => {\n    if (!controllerRef.current) {\n      initController();\n    }\n\n    const controller = controllerRef.current!;\n    controller.observer.observe(target);\n\n    if (targetCallback) {\n      controller.callbacks.set(target, targetCallback);\n    }\n\n    return () => {\n      if (targetCallback) {\n        controller.callbacks.delete(target);\n      }\n\n      controller.observer.unobserve(target);\n    };\n    // Arguments should never change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n\n  return { observe, freeze, unfreeze };\n}\n\nexport function useOnIntersect(\n  targetRef: RefObject<HTMLDivElement>, observe?: ObserveFn, callback?: TargetCallback,\n) {\n  useEffect(() => {\n    return observe ? observe(targetRef.current!, callback) : undefined;\n    // Arguments should never change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n\nexport function useIsIntersecting(\n  targetRef: RefObject<HTMLDivElement>, observe?: ObserveFn, callback?: TargetCallback,\n) {\n  const [isIntersecting, setIsIntersecting] = useState(!observe);\n\n  useOnIntersect(targetRef, observe, (entry) => {\n    setIsIntersecting(entry.isIntersecting);\n\n    if (callback) {\n      callback(entry);\n    }\n  });\n\n  return isIntersecting;\n}\n","import { useEffect, useLayoutEffect, useRef } from '../lib/teact/teact';\n\nfunction useInterval(callback: NoneToVoidFunction, delay?: number, noFirst = false) {\n  const savedCallback = useRef(callback);\n\n  useLayoutEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (delay === undefined) {\n      return undefined;\n    }\n\n    const id = setInterval(() => savedCallback.current(), delay);\n    if (!noFirst) savedCallback.current();\n\n    return () => clearInterval(id);\n  }, [delay, noFirst]);\n}\n\nexport default useInterval;\n","import { useEffect } from '../lib/teact/teact';\n\nimport { ApiMediaFormat } from '../api/types';\n\nimport * as mediaLoader from '../util/mediaLoader';\nimport useForceUpdate from './useForceUpdate';\n\nconst useMedia = (\n  mediaHash: string | false | undefined,\n  noLoad = false,\n  mediaFormat = ApiMediaFormat.BlobUrl,\n  cacheBuster?: number,\n  delay?: number | false,\n) => {\n  const mediaData = mediaHash ? mediaLoader.getFromMemory(mediaHash) : undefined;\n  const forceUpdate = useForceUpdate();\n\n  useEffect(() => {\n    if (!noLoad && mediaHash && !mediaData) {\n      const startedAt = Date.now();\n\n      mediaLoader.fetch(mediaHash, mediaFormat).then(() => {\n        const spentTime = Date.now() - startedAt;\n        if (!delay || spentTime >= delay) {\n          forceUpdate();\n        } else {\n          setTimeout(forceUpdate, delay - spentTime);\n        }\n      });\n    }\n  }, [noLoad, mediaHash, mediaData, mediaFormat, cacheBuster, forceUpdate, delay]);\n\n  return mediaData;\n};\n\nexport default useMedia;\n","import { IS_IOS } from './environment';\nimport forceReflow from './forceReflow';\n\nconst resetScroll = (container: HTMLDivElement, scrollTop?: number) => {\n  if (IS_IOS) {\n    container.style.overflow = 'hidden';\n  }\n\n  if (scrollTop !== undefined) {\n    container.scrollTop = scrollTop;\n  }\n\n  if (IS_IOS) {\n    container.style.overflow = '';\n  }\n};\n\n// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1264266\nexport function patchChromiumScroll(element: HTMLElement) {\n  element.style.display = 'none';\n  forceReflow(element);\n  element.style.display = '';\n}\n\nexport default resetScroll;\n","import { DEBUG } from '../config';\n\nconst safePlay = (mediaEl: HTMLMediaElement) => {\n  mediaEl.play().catch((err) => {\n    if (DEBUG) {\n      // eslint-disable-next-line no-console\n      console.warn(err, mediaEl);\n    }\n  });\n};\n\nexport default safePlay;\n"],"names":["cn","createClassNameBuilder","media","icon","memo","className","size","chat","user","photo","userStatus","text","isSavedMessages","noVideo","noLoop","lastSyncTime","observeIntersection","onClick","loadFullUser","getActions","ref","useRef","videoRef","isIntersecting","useIsIntersecting","isDeleted","isDeletedUser","isReplies","isChatWithRepliesBot","id","imageHash","videoHash","hasVideoAvatar","profilePhoto","fullInfo","shouldShowVideo","Boolean","isPremium","isVideo","shouldPlayVideo","shouldFetchBig","getChatAvatarHash","undefined","useVideoAutoPause","useEffect","video","current","returnToStart","currentTime","addEventListener","removeEventListener","userId","imgBlobUrl","useMedia","ApiMediaFormat","videoBlobUrl","hasBlobUrl","transitionClassNames","useShowTransition","lang","useLang","content","author","getUserFullName","getChatTitle","buildClassName","src","alt","decoding","muted","autoPlay","disablePictureInPicture","loop","playsInline","userFullName","getFirstLetters","title","isUserId","isOnline","isUserOnline","fullClassName","getUserColorKey","hasMedia","handleClick","useCallback","e","senderId","IS_TEST","renderText","playerRef","canPlay","wasPlaying","paused","canPlayRef","freezePlaying","pause","unfreezePlaying","document","body","contains","safePlay","unfreezePlayingOnRaf","fastRaf","useBackgroundMode","useHeavyAnimationCheck","DEFAULT_LIST_SELECTOR","DEFAULT_PRELOAD_BACKWARDS","DEFAULT_SENSITIVE_AREA","items","itemSelector","preloadBackwards","sensitiveArea","withAbsolutePositioning","maxHeight","noScrollRestore","noScrollRestoreOnTop","noFastList","cacheBuster","children","onLoadMore","onScroll","onKeyDown","onDragOver","onDragLeave","containerRef","stateRef","loadMoreBackwards","loadMoreForwards","useMemo","debounce","noScroll","direction","LoadMoreDirection","length","scrollHeight","clientHeight","useLayoutEffect","container","state","newScrollTop","listItemElements","querySelectorAll","currentAnchor","Array","from","includes","scrollTop","getBoundingClientRect","top","currentAnchorTop","nextAnchor","resetScroll","isScrollTopJustUpdated","handleScroll","listLength","offsetHeight","isNearTop","offsetTop","isNearBottom","isUpdated","nextAnchorTop","newAnchorTop","offsetParent","teactFastList","style","buildStyle","IS_ANDROID","dialogRef","isOpen","header","hasCloseButton","noBackdrop","onClose","onCloseAnimationEnd","onEnter","shouldSkipHistoryAnimations","shouldRender","modalRef","captureKeyboardListeners","onEsc","element","handleKeyDown","key","preventDefault","stopPropagation","focusableElements","currentFocusedIndex","findIndex","em","isSameNode","activeElement","newFocusedIndex","shiftKey","focus","trapFocus","useHistoryBack","isActive","onBack","useEffectWithPrevDeps","prevIsOpen","classList","toggle","dispatchHeavyAnimationEvent","remove","Portal","tabIndex","role","Button","round","color","ariaLabel","containerId","elementRef","createElement","querySelector","add","appendChild","TeactDOM","removeChild","selectCurrentLimit","global","limit","appConfig","DEFAULT_LIMITS","selectIsCurrentUserPremium","limits","value","selectPremiumLimit","getViewportSlice","sourceIds","listSlice","offsetId","index","indexOf","indexForDirection","Math","max","to","newViewportIds","slice","areSomeLocal","areAllLocal","listIds","isDisabled","lastParamsRef","viewportIdsRef","forceUpdate","useForceUpdate","prevListIds","usePrevious","prevIsDisabled","areSortedArraysEqual","getMore","viewportIds","useIntersectionObserver","rootCallback","rootRef","throttleMs","debounceMs","shouldSkipFirst","margin","threshold","controllerRef","rootCallbackRef","freezeFlagsRef","onUnfreezeRef","freeze","unfreeze","observer","disconnect","callbacks","clear","observe","target","targetCallback","Map","entriesAccumulator","observerCallbackSync","entries","values","forEach","entry","callback","get","scheduler","throttle","observerCallback","IntersectionObserver","set","root","rootMargin","initController","controller","delete","unobserve","useOnIntersect","targetRef","setIsIntersecting","useState","delay","noFirst","savedCallback","setInterval","clearInterval","mediaHash","noLoad","mediaFormat","mediaData","mediaLoader","startedAt","Date","now","then","spentTime","setTimeout","patchChromiumScroll","display","forceReflow","IS_IOS","overflow","mediaEl","play","catch","err","DEBUG","console","warn"],"sourceRoot":""}