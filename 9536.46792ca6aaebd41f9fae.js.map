{"version":3,"file":"9536.46792ca6aaebd41f9fae.js","mappings":"uBAAAA,EAAOC,QAAU,+grB,UCIjBD,EAAOC,QAAU,SAASC,GACzB,SAASC,EAAIC,GACQ,oBAAZC,UACJA,QAAQD,OAASC,QAAQF,KAAK,kBAAmBC,GAQtD,IAC2B,oBAAfE,YAJmB,oBAAhBC,aAA2D,oBAArBC,iBAKnDF,WAAWJ,GACe,oBAATO,KACjBA,KAAKC,KAAK,KAAMR,GAEhBC,EAAI,yCAEJ,MAAOC,GACRD,EAAIC,M,eCxBN,EAAQ,MAAR,CAAsF,EAAQ,UCC1FO,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAab,QAGrB,IAAID,EAASW,EAAyBE,GAAY,CAGjDZ,QAAS,IAOV,OAHAe,EAAoBH,GAAUb,EAAQA,EAAOC,QAASW,GAG/CZ,EAAOC,QCpBfW,EAAoBK,EAAKjB,IACxB,IAAIkB,EAASlB,GAAUA,EAAOmB,WAC7B,IAAOnB,EAAiB,QACxB,IAAM,EAEP,OADAY,EAAoBQ,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRN,EAAoBQ,EAAI,CAACnB,EAASqB,KACjC,IAAI,IAAIC,KAAOD,EACXV,EAAoBY,EAAEF,EAAYC,KAASX,EAAoBY,EAAEvB,EAASsB,IAC5EE,OAAOC,eAAezB,EAASsB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EX,EAAoBY,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAetB,KAAKmB,EAAKC,G,2BCGlFG,OAAOC,qBAAuBC,UAC5BC,KAAKC,YAAY,CAAEC,KAAM,iBAG3BF,KAAKG,UAAaC,IAChB,MAAM,GAAEC,EAAF,KAAMC,GAASF,EAAMG,KACrBC,EAAS,IAAIC,WAEnBD,EAAOpC,iBAAiB,WAAW,KACjC,MAAMsC,EAASF,EAAOG,OAEhBC,EAAOF,EAAOG,WACdC,EAAUjB,OAAOkB,QAAQH,GAC/Bf,OAAOmB,OAAOC,IAAI,IAAIC,WAAWR,GAASI,GAE1C,MAEMK,EAFUtB,OAAOuB,MAAM,UAAW,SAAU,CAAC,SAAU,UAEjDC,CAAQP,EAASF,GAE7B,IADkBf,OAAOyB,SAASH,EAAK,OAOrC,OALAtB,OAAO0B,MAAMJ,GACbtB,OAAO0B,MAAMT,QACbd,KAAKC,YAAY,CACfC,KAAM,SAAUG,GAAAA,EAAImB,MAAO,EAAGC,OAAQ,EAAGd,OAAQ,OAIrD,MAAMa,EAAQ3B,OAAOyB,SAASH,EAAM,EAAG,OACjCM,EAAS5B,OAAOyB,SAASH,EAAM,EAAG,OAExCtB,OAAO0B,MAAMJ,GAEb,MAEMO,EAFS7B,OAAOuB,MAAM,SAAU,SAAU,CAAC,SAAU,UAEzCO,CAAOb,EAASF,GAE5BgB,EAAa,IAAIV,WAAWrB,OAAOmB,OAAON,OAAQgB,EAAWF,EAAQC,EAAS,GAC9Ed,EAAS,IAAIkB,kBAAkBD,GACrC/B,OAAO0B,MAAMG,GACb7B,OAAO0B,MAAMT,GAEbd,KAAKC,YAAY,CACfC,KAAM,SAAUG,GAAAA,EAAImB,MAAAA,EAAOC,OAAAA,EAAQd,OAAAA,OAIvCH,EAAOsB,kBAAkBxB,K","sources":["webpack://telegram-t/./src/lib/webp/webp_wasm.js","webpack://telegram-t/./node_modules/script-loader/addScript.js","webpack://telegram-t/./src/lib/webp/webp_wasm.js?f4ee","webpack://telegram-t/webpack/bootstrap","webpack://telegram-t/webpack/runtime/compat get default export","webpack://telegram-t/webpack/runtime/define property getters","webpack://telegram-t/webpack/runtime/hasOwnProperty shorthand","webpack://telegram-t/./src/lib/webp/webp_wasm.worker.js"],"sourcesContent":["module.exports = \"var Module = typeof Module !== \\\"undefined\\\" ? Module : {};\\nvar moduleOverrides = {};\\nvar key;\\n\\nfor (key in Module) {\\n  if (Module.hasOwnProperty(key)) {\\n    moduleOverrides[key] = Module[key];\\n  }\\n}\\n\\nvar arguments_ = [];\\nvar thisProgram = \\\"./this.program\\\";\\n\\nvar quit_ = function (status, toThrow) {\\n  throw toThrow;\\n};\\n\\nvar ENVIRONMENT_IS_WEB = false;\\nvar ENVIRONMENT_IS_WORKER = false;\\nvar ENVIRONMENT_IS_NODE = false;\\nvar ENVIRONMENT_IS_SHELL = false;\\nENVIRONMENT_IS_WEB = typeof window === \\\"object\\\";\\nENVIRONMENT_IS_WORKER = typeof importScripts === \\\"function\\\";\\nENVIRONMENT_IS_NODE = typeof process === \\\"object\\\" && typeof process.versions === \\\"object\\\" && typeof process.versions.node === \\\"string\\\";\\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\\nvar scriptDirectory = \\\"\\\";\\n\\nfunction locateFile(path) {\\n  if (Module[\\\"locateFile\\\"]) {\\n    return Module[\\\"locateFile\\\"](path, scriptDirectory);\\n  }\\n\\n  return scriptDirectory + path;\\n}\\n\\nvar read_, readAsync, readBinary, setWindowTitle;\\nvar nodeFS;\\nvar nodePath;\\n\\nif (ENVIRONMENT_IS_NODE) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = require(\\\"path\\\").dirname(scriptDirectory) + \\\"/\\\";\\n  } else {\\n    scriptDirectory = __dirname + \\\"/\\\";\\n  }\\n\\n  read_ = function shell_read(filename, binary) {\\n    if (!nodeFS) nodeFS = require(\\\"fs\\\");\\n    if (!nodePath) nodePath = require(\\\"path\\\");\\n    filename = nodePath[\\\"normalize\\\"](filename);\\n    return nodeFS[\\\"readFileSync\\\"](filename, binary ? null : \\\"utf8\\\");\\n  };\\n\\n  readBinary = function readBinary(filename) {\\n    var ret = read_(filename, true);\\n\\n    if (!ret.buffer) {\\n      ret = new Uint8Array(ret);\\n    }\\n\\n    assert(ret.buffer);\\n    return ret;\\n  };\\n\\n  if (process[\\\"argv\\\"].length > 1) {\\n    thisProgram = process[\\\"argv\\\"][1].replace(/\\\\\\\\/g, \\\"/\\\");\\n  }\\n\\n  arguments_ = process[\\\"argv\\\"].slice(2);\\n\\n  if (typeof module !== \\\"undefined\\\") {\\n    module[\\\"exports\\\"] = Module;\\n  }\\n\\n  process[\\\"on\\\"](\\\"uncaughtException\\\", function (ex) {\\n    if (!(ex instanceof ExitStatus)) {\\n      throw ex;\\n    }\\n  });\\n  process[\\\"on\\\"](\\\"unhandledRejection\\\", abort);\\n\\n  quit_ = function (status) {\\n    process[\\\"exit\\\"](status);\\n  };\\n\\n  Module[\\\"inspect\\\"] = function () {\\n    return \\\"[Emscripten Module object]\\\";\\n  };\\n} else if (ENVIRONMENT_IS_SHELL) {\\n  if (typeof read != \\\"undefined\\\") {\\n    read_ = function shell_read(f) {\\n      return read(f);\\n    };\\n  }\\n\\n  readBinary = function readBinary(f) {\\n    var data;\\n\\n    if (typeof readbuffer === \\\"function\\\") {\\n      return new Uint8Array(readbuffer(f));\\n    }\\n\\n    data = read(f, \\\"binary\\\");\\n    assert(typeof data === \\\"object\\\");\\n    return data;\\n  };\\n\\n  if (typeof scriptArgs != \\\"undefined\\\") {\\n    arguments_ = scriptArgs;\\n  } else if (typeof arguments != \\\"undefined\\\") {\\n    arguments_ = arguments;\\n  }\\n\\n  if (typeof quit === \\\"function\\\") {\\n    quit_ = function (status) {\\n      quit(status);\\n    };\\n  }\\n\\n  if (typeof print !== \\\"undefined\\\") {\\n    if (typeof console === \\\"undefined\\\") console = {};\\n    console.log = print;\\n    console.warn = console.error = typeof printErr !== \\\"undefined\\\" ? printErr : print;\\n  }\\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = self.location.href;\\n  } else if (document.currentScript) {\\n    scriptDirectory = document.currentScript.src;\\n  }\\n\\n  if (scriptDirectory.indexOf(\\\"blob:\\\") !== 0) {\\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\\\"/\\\") + 1);\\n  } else {\\n    scriptDirectory = \\\"\\\";\\n  }\\n\\n  {\\n    read_ = function shell_read(url) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, false);\\n      xhr.send(null);\\n      return xhr.responseText;\\n    };\\n\\n    if (ENVIRONMENT_IS_WORKER) {\\n      readBinary = function readBinary(url) {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        xhr.responseType = \\\"arraybuffer\\\";\\n        xhr.send(null);\\n        return new Uint8Array(xhr.response);\\n      };\\n    }\\n\\n    readAsync = function readAsync(url, onload, onerror) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, true);\\n      xhr.responseType = \\\"arraybuffer\\\";\\n\\n      xhr.onload = function xhr_onload() {\\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\\n          onload(xhr.response);\\n          return;\\n        }\\n\\n        onerror();\\n      };\\n\\n      xhr.onerror = onerror;\\n      xhr.send(null);\\n    };\\n  }\\n\\n  setWindowTitle = function (title) {\\n    document.title = title;\\n  };\\n} else {}\\n\\nvar out = Module[\\\"print\\\"] || console.log.bind(console);\\nvar err = Module[\\\"printErr\\\"] || console.warn.bind(console);\\n\\nfor (key in moduleOverrides) {\\n  if (moduleOverrides.hasOwnProperty(key)) {\\n    Module[key] = moduleOverrides[key];\\n  }\\n}\\n\\nmoduleOverrides = null;\\nif (Module[\\\"arguments\\\"]) arguments_ = Module[\\\"arguments\\\"];\\nif (Module[\\\"thisProgram\\\"]) thisProgram = Module[\\\"thisProgram\\\"];\\nif (Module[\\\"quit\\\"]) quit_ = Module[\\\"quit\\\"];\\nvar wasmBinary;\\nif (Module[\\\"wasmBinary\\\"]) wasmBinary = Module[\\\"wasmBinary\\\"];\\nvar noExitRuntime;\\nif (Module[\\\"noExitRuntime\\\"]) noExitRuntime = Module[\\\"noExitRuntime\\\"];\\n\\nif (typeof WebAssembly !== \\\"object\\\") {\\n  abort(\\\"no native wasm support detected\\\");\\n}\\n\\nfunction getValue(ptr, type, noSafe) {\\n  type = type || \\\"i8\\\";\\n  if (type.charAt(type.length - 1) === \\\"*\\\") type = \\\"i32\\\";\\n\\n  switch (type) {\\n    case \\\"i1\\\":\\n      return HEAP8[ptr >> 0];\\n\\n    case \\\"i8\\\":\\n      return HEAP8[ptr >> 0];\\n\\n    case \\\"i16\\\":\\n      return HEAP16[ptr >> 1];\\n\\n    case \\\"i32\\\":\\n      return HEAP32[ptr >> 2];\\n\\n    case \\\"i64\\\":\\n      return HEAP32[ptr >> 2];\\n\\n    case \\\"float\\\":\\n      return HEAPF32[ptr >> 2];\\n\\n    case \\\"double\\\":\\n      return HEAPF64[ptr >> 3];\\n\\n    default:\\n      abort(\\\"invalid type for getValue: \\\" + type);\\n  }\\n\\n  return null;\\n}\\n\\nvar wasmMemory;\\nvar wasmTable = new WebAssembly.Table({\\n  \\\"initial\\\": 157,\\n  \\\"maximum\\\": 157 + 0,\\n  \\\"element\\\": \\\"anyfunc\\\"\\n});\\nvar ABORT = false;\\nvar EXITSTATUS = 0;\\n\\nfunction assert(condition, text) {\\n  if (!condition) {\\n    abort(\\\"Assertion failed: \\\" + text);\\n  }\\n}\\n\\nfunction getCFunc(ident) {\\n  var func = Module[\\\"_\\\" + ident];\\n  assert(func, \\\"Cannot call unknown function \\\" + ident + \\\", make sure it is exported\\\");\\n  return func;\\n}\\n\\nfunction ccall(ident, returnType, argTypes, args, opts) {\\n  var toC = {\\n    \\\"string\\\": function (str) {\\n      var ret = 0;\\n\\n      if (str !== null && str !== undefined && str !== 0) {\\n        var len = (str.length << 2) + 1;\\n        ret = stackAlloc(len);\\n        stringToUTF8(str, ret, len);\\n      }\\n\\n      return ret;\\n    },\\n    \\\"array\\\": function (arr) {\\n      var ret = stackAlloc(arr.length);\\n      writeArrayToMemory(arr, ret);\\n      return ret;\\n    }\\n  };\\n\\n  function convertReturnValue(ret) {\\n    if (returnType === \\\"string\\\") return UTF8ToString(ret);\\n    if (returnType === \\\"boolean\\\") return Boolean(ret);\\n    return ret;\\n  }\\n\\n  var func = getCFunc(ident);\\n  var cArgs = [];\\n  var stack = 0;\\n\\n  if (args) {\\n    for (var i = 0; i < args.length; i++) {\\n      var converter = toC[argTypes[i]];\\n\\n      if (converter) {\\n        if (stack === 0) stack = stackSave();\\n        cArgs[i] = converter(args[i]);\\n      } else {\\n        cArgs[i] = args[i];\\n      }\\n    }\\n  }\\n\\n  var ret = func.apply(null, cArgs);\\n  ret = convertReturnValue(ret);\\n  if (stack !== 0) stackRestore(stack);\\n  return ret;\\n}\\n\\nfunction cwrap(ident, returnType, argTypes, opts) {\\n  argTypes = argTypes || [];\\n  var numericArgs = argTypes.every(function (type) {\\n    return type === \\\"number\\\";\\n  });\\n  var numericRet = returnType !== \\\"string\\\";\\n\\n  if (numericRet && numericArgs && !opts) {\\n    return getCFunc(ident);\\n  }\\n\\n  return function () {\\n    return ccall(ident, returnType, argTypes, arguments, opts);\\n  };\\n}\\n\\nvar UTF8Decoder = typeof TextDecoder !== \\\"undefined\\\" ? new TextDecoder(\\\"utf8\\\") : undefined;\\n\\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\\n  var endIdx = idx + maxBytesToRead;\\n  var endPtr = idx;\\n\\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n\\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\\n  } else {\\n    var str = \\\"\\\";\\n\\n    while (idx < endPtr) {\\n      var u0 = heap[idx++];\\n\\n      if (!(u0 & 128)) {\\n        str += String.fromCharCode(u0);\\n        continue;\\n      }\\n\\n      var u1 = heap[idx++] & 63;\\n\\n      if ((u0 & 224) == 192) {\\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\\n        continue;\\n      }\\n\\n      var u2 = heap[idx++] & 63;\\n\\n      if ((u0 & 240) == 224) {\\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\\n      } else {\\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\\n      }\\n\\n      if (u0 < 65536) {\\n        str += String.fromCharCode(u0);\\n      } else {\\n        var ch = u0 - 65536;\\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\\n      }\\n    }\\n  }\\n\\n  return str;\\n}\\n\\nfunction UTF8ToString(ptr, maxBytesToRead) {\\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\"\\\";\\n}\\n\\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\n  if (!(maxBytesToWrite > 0)) return 0;\\n  var startIdx = outIdx;\\n  var endIdx = outIdx + maxBytesToWrite - 1;\\n\\n  for (var i = 0; i < str.length; ++i) {\\n    var u = str.charCodeAt(i);\\n\\n    if (u >= 55296 && u <= 57343) {\\n      var u1 = str.charCodeAt(++i);\\n      u = 65536 + ((u & 1023) << 10) | u1 & 1023;\\n    }\\n\\n    if (u <= 127) {\\n      if (outIdx >= endIdx) break;\\n      heap[outIdx++] = u;\\n    } else if (u <= 2047) {\\n      if (outIdx + 1 >= endIdx) break;\\n      heap[outIdx++] = 192 | u >> 6;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else if (u <= 65535) {\\n      if (outIdx + 2 >= endIdx) break;\\n      heap[outIdx++] = 224 | u >> 12;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else {\\n      if (outIdx + 3 >= endIdx) break;\\n      heap[outIdx++] = 240 | u >> 18;\\n      heap[outIdx++] = 128 | u >> 12 & 63;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    }\\n  }\\n\\n  heap[outIdx] = 0;\\n  return outIdx - startIdx;\\n}\\n\\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n}\\n\\nfunction writeArrayToMemory(array, buffer) {\\n  HEAP8.set(array, buffer);\\n}\\n\\nvar WASM_PAGE_SIZE = 65536;\\n\\nfunction alignUp(x, multiple) {\\n  if (x % multiple > 0) {\\n    x += multiple - x % multiple;\\n  }\\n\\n  return x;\\n}\\n\\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\n\\nfunction updateGlobalBufferAndViews(buf) {\\n  buffer = buf;\\n  Module[\\\"HEAP8\\\"] = HEAP8 = new Int8Array(buf);\\n  Module[\\\"HEAP16\\\"] = HEAP16 = new Int16Array(buf);\\n  Module[\\\"HEAP32\\\"] = HEAP32 = new Int32Array(buf);\\n  Module[\\\"HEAPU8\\\"] = HEAPU8 = new Uint8Array(buf);\\n  Module[\\\"HEAPU16\\\"] = HEAPU16 = new Uint16Array(buf);\\n  Module[\\\"HEAPU32\\\"] = HEAPU32 = new Uint32Array(buf);\\n  Module[\\\"HEAPF32\\\"] = HEAPF32 = new Float32Array(buf);\\n  Module[\\\"HEAPF64\\\"] = HEAPF64 = new Float64Array(buf);\\n}\\n\\nvar DYNAMIC_BASE = 5259680,\\n    DYNAMICTOP_PTR = 16640;\\nvar INITIAL_INITIAL_MEMORY = Module[\\\"INITIAL_MEMORY\\\"] || 16777216;\\n\\nif (Module[\\\"wasmMemory\\\"]) {\\n  wasmMemory = Module[\\\"wasmMemory\\\"];\\n} else {\\n  wasmMemory = new WebAssembly.Memory({\\n    \\\"initial\\\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\\n    \\\"maximum\\\": 2147483648 / WASM_PAGE_SIZE\\n  });\\n}\\n\\nif (wasmMemory) {\\n  buffer = wasmMemory.buffer;\\n}\\n\\nINITIAL_INITIAL_MEMORY = buffer.byteLength;\\nupdateGlobalBufferAndViews(buffer);\\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\\n\\nfunction callRuntimeCallbacks(callbacks) {\\n  while (callbacks.length > 0) {\\n    var callback = callbacks.shift();\\n\\n    if (typeof callback == \\\"function\\\") {\\n      callback(Module);\\n      continue;\\n    }\\n\\n    var func = callback.func;\\n\\n    if (typeof func === \\\"number\\\") {\\n      if (callback.arg === undefined) {\\n        Module[\\\"dynCall_v\\\"](func);\\n      } else {\\n        Module[\\\"dynCall_vi\\\"](func, callback.arg);\\n      }\\n    } else {\\n      func(callback.arg === undefined ? null : callback.arg);\\n    }\\n  }\\n}\\n\\nvar __ATPRERUN__ = [];\\nvar __ATINIT__ = [];\\nvar __ATMAIN__ = [];\\nvar __ATPOSTRUN__ = [];\\nvar runtimeInitialized = false;\\n\\nfunction preRun() {\\n  if (Module[\\\"preRun\\\"]) {\\n    if (typeof Module[\\\"preRun\\\"] == \\\"function\\\") Module[\\\"preRun\\\"] = [Module[\\\"preRun\\\"]];\\n\\n    while (Module[\\\"preRun\\\"].length) {\\n      addOnPreRun(Module[\\\"preRun\\\"].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPRERUN__);\\n}\\n\\nfunction initRuntime() {\\n  runtimeInitialized = true;\\n  callRuntimeCallbacks(__ATINIT__);\\n}\\n\\nfunction preMain() {\\n  callRuntimeCallbacks(__ATMAIN__);\\n}\\n\\nfunction postRun() {\\n  if (Module[\\\"postRun\\\"]) {\\n    if (typeof Module[\\\"postRun\\\"] == \\\"function\\\") Module[\\\"postRun\\\"] = [Module[\\\"postRun\\\"]];\\n\\n    while (Module[\\\"postRun\\\"].length) {\\n      addOnPostRun(Module[\\\"postRun\\\"].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPOSTRUN__);\\n}\\n\\nfunction addOnPreRun(cb) {\\n  __ATPRERUN__.unshift(cb);\\n}\\n\\nfunction addOnPostRun(cb) {\\n  __ATPOSTRUN__.unshift(cb);\\n}\\n\\nvar runDependencies = 0;\\nvar runDependencyWatcher = null;\\nvar dependenciesFulfilled = null;\\n\\nfunction addRunDependency(id) {\\n  runDependencies++;\\n\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n}\\n\\nfunction removeRunDependency(id) {\\n  runDependencies--;\\n\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n\\n  if (runDependencies == 0) {\\n    if (runDependencyWatcher !== null) {\\n      clearInterval(runDependencyWatcher);\\n      runDependencyWatcher = null;\\n    }\\n\\n    if (dependenciesFulfilled) {\\n      var callback = dependenciesFulfilled;\\n      dependenciesFulfilled = null;\\n      callback();\\n    }\\n  }\\n}\\n\\nModule[\\\"preloadedImages\\\"] = {};\\nModule[\\\"preloadedAudios\\\"] = {};\\n\\nfunction abort(what) {\\n  if (Module[\\\"onAbort\\\"]) {\\n    Module[\\\"onAbort\\\"](what);\\n  }\\n\\n  what += \\\"\\\";\\n  err(what);\\n  ABORT = true;\\n  EXITSTATUS = 1;\\n  what = \\\"abort(\\\" + what + \\\"). Build with -s ASSERTIONS=1 for more info.\\\";\\n  var e = new WebAssembly.RuntimeError(what);\\n  throw e;\\n}\\n\\nfunction hasPrefix(str, prefix) {\\n  return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\\n}\\n\\nvar dataURIPrefix = \\\"data:application/octet-stream;base64,\\\";\\n\\nfunction isDataURI(filename) {\\n  return hasPrefix(filename, dataURIPrefix);\\n}\\n\\nvar fileURIPrefix = \\\"file://\\\";\\n\\nfunction isFileURI(filename) {\\n  return hasPrefix(filename, fileURIPrefix);\\n}\\n\\nvar wasmBinaryFile = \\\"webp_wasm.wasm\\\";\\n\\nif (!isDataURI(wasmBinaryFile)) {\\n  wasmBinaryFile = locateFile(wasmBinaryFile);\\n}\\n\\nfunction getBinary() {\\n  try {\\n    if (wasmBinary) {\\n      return new Uint8Array(wasmBinary);\\n    }\\n\\n    if (readBinary) {\\n      return readBinary(wasmBinaryFile);\\n    } else {\\n      throw \\\"both async and sync fetching of the wasm failed\\\";\\n    }\\n  } catch (err) {\\n    abort(err);\\n  }\\n}\\n\\nfunction getBinaryPromise() {\\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \\\"function\\\" && !isFileURI(wasmBinaryFile)) {\\n    return fetch(wasmBinaryFile, {\\n      credentials: \\\"same-origin\\\"\\n    }).then(function (response) {\\n      if (!response[\\\"ok\\\"]) {\\n        throw \\\"failed to load wasm binary file at '\\\" + wasmBinaryFile + \\\"'\\\";\\n      }\\n\\n      return response[\\\"arrayBuffer\\\"]();\\n    }).catch(function () {\\n      return getBinary();\\n    });\\n  }\\n\\n  return new Promise(function (resolve, reject) {\\n    resolve(getBinary());\\n  });\\n}\\n\\nfunction createWasm() {\\n  var info = {\\n    \\\"a\\\": asmLibraryArg\\n  };\\n\\n  function receiveInstance(instance, module) {\\n    var exports = instance.exports;\\n    Module[\\\"asm\\\"] = exports;\\n    removeRunDependency(\\\"wasm-instantiate\\\");\\n  }\\n\\n  addRunDependency(\\\"wasm-instantiate\\\");\\n\\n  function receiveInstantiatedSource(output) {\\n    receiveInstance(output[\\\"instance\\\"]);\\n  }\\n\\n  function instantiateArrayBuffer(receiver) {\\n    return getBinaryPromise().then(function (binary) {\\n      return WebAssembly.instantiate(binary, info);\\n    }).then(receiver, function (reason) {\\n      err(\\\"failed to asynchronously prepare wasm: \\\" + reason);\\n      abort(reason);\\n    });\\n  }\\n\\n  function instantiateAsync() {\\n    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \\\"function\\\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \\\"function\\\") {\\n      fetch(wasmBinaryFile, {\\n        credentials: \\\"same-origin\\\"\\n      }).then(function (response) {\\n        var result = WebAssembly.instantiateStreaming(response, info);\\n        return result.then(receiveInstantiatedSource, function (reason) {\\n          err(\\\"wasm streaming compile failed: \\\" + reason);\\n          err(\\\"falling back to ArrayBuffer instantiation\\\");\\n          return instantiateArrayBuffer(receiveInstantiatedSource);\\n        });\\n      });\\n    } else {\\n      return instantiateArrayBuffer(receiveInstantiatedSource);\\n    }\\n  }\\n\\n  if (Module[\\\"instantiateWasm\\\"]) {\\n    try {\\n      var exports = Module[\\\"instantiateWasm\\\"](info, receiveInstance);\\n      return exports;\\n    } catch (e) {\\n      err(\\\"Module.instantiateWasm callback failed with error: \\\" + e);\\n      return false;\\n    }\\n  }\\n\\n  instantiateAsync();\\n  return {};\\n}\\n\\n__ATINIT__.push({\\n  func: function () {\\n    ___wasm_call_ctors();\\n  }\\n});\\n\\nfunction ___assert_fail(condition, filename, line, func) {\\n  abort(\\\"Assertion failed: \\\" + UTF8ToString(condition) + \\\", at: \\\" + [filename ? UTF8ToString(filename) : \\\"unknown filename\\\", line, func ? UTF8ToString(func) : \\\"unknown function\\\"]);\\n}\\n\\nfunction _emscripten_memcpy_big(dest, src, num) {\\n  HEAPU8.copyWithin(dest, src, src + num);\\n}\\n\\nfunction _emscripten_get_heap_size() {\\n  return HEAPU8.length;\\n}\\n\\nfunction emscripten_realloc_buffer(size) {\\n  try {\\n    wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\\n    updateGlobalBufferAndViews(wasmMemory.buffer);\\n    return 1;\\n  } catch (e) {}\\n}\\n\\nfunction _emscripten_resize_heap(requestedSize) {\\n  requestedSize = requestedSize >>> 0;\\n\\n  var oldSize = _emscripten_get_heap_size();\\n\\n  var PAGE_MULTIPLE = 65536;\\n  var maxHeapSize = 2147483648;\\n\\n  if (requestedSize > maxHeapSize) {\\n    return false;\\n  }\\n\\n  var minHeapSize = 16777216;\\n\\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\\n    var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\\n    var replacement = emscripten_realloc_buffer(newSize);\\n\\n    if (replacement) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nvar asmLibraryArg = {\\n  \\\"a\\\": ___assert_fail,\\n  \\\"b\\\": _emscripten_memcpy_big,\\n  \\\"c\\\": _emscripten_resize_heap,\\n  \\\"memory\\\": wasmMemory,\\n  \\\"table\\\": wasmTable\\n};\\nvar asm = createWasm();\\n\\nvar ___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = function () {\\n  return (___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = Module[\\\"asm\\\"][\\\"d\\\"]).apply(null, arguments);\\n};\\n\\nvar _version = Module[\\\"_version\\\"] = function () {\\n  return (_version = Module[\\\"_version\\\"] = Module[\\\"asm\\\"][\\\"e\\\"]).apply(null, arguments);\\n};\\n\\nvar _getInfo = Module[\\\"_getInfo\\\"] = function () {\\n  return (_getInfo = Module[\\\"_getInfo\\\"] = Module[\\\"asm\\\"][\\\"f\\\"]).apply(null, arguments);\\n};\\n\\nvar _malloc = Module[\\\"_malloc\\\"] = function () {\\n  return (_malloc = Module[\\\"_malloc\\\"] = Module[\\\"asm\\\"][\\\"g\\\"]).apply(null, arguments);\\n};\\n\\nvar _decode = Module[\\\"_decode\\\"] = function () {\\n  return (_decode = Module[\\\"_decode\\\"] = Module[\\\"asm\\\"][\\\"h\\\"]).apply(null, arguments);\\n};\\n\\nvar _free = Module[\\\"_free\\\"] = function () {\\n  return (_free = Module[\\\"_free\\\"] = Module[\\\"asm\\\"][\\\"i\\\"]).apply(null, arguments);\\n};\\n\\nvar stackSave = Module[\\\"stackSave\\\"] = function () {\\n  return (stackSave = Module[\\\"stackSave\\\"] = Module[\\\"asm\\\"][\\\"j\\\"]).apply(null, arguments);\\n};\\n\\nvar stackRestore = Module[\\\"stackRestore\\\"] = function () {\\n  return (stackRestore = Module[\\\"stackRestore\\\"] = Module[\\\"asm\\\"][\\\"k\\\"]).apply(null, arguments);\\n};\\n\\nvar stackAlloc = Module[\\\"stackAlloc\\\"] = function () {\\n  return (stackAlloc = Module[\\\"stackAlloc\\\"] = Module[\\\"asm\\\"][\\\"l\\\"]).apply(null, arguments);\\n};\\n\\nvar dynCall_vi = Module[\\\"dynCall_vi\\\"] = function () {\\n  return (dynCall_vi = Module[\\\"dynCall_vi\\\"] = Module[\\\"asm\\\"][\\\"m\\\"]).apply(null, arguments);\\n};\\n\\nModule[\\\"cwrap\\\"] = cwrap;\\nModule[\\\"getValue\\\"] = getValue;\\nvar calledRun;\\n\\nfunction ExitStatus(status) {\\n  this.name = \\\"ExitStatus\\\";\\n  this.message = \\\"Program terminated with exit(\\\" + status + \\\")\\\";\\n  this.status = status;\\n}\\n\\ndependenciesFulfilled = function runCaller() {\\n  if (!calledRun) run();\\n  if (!calledRun) dependenciesFulfilled = runCaller;\\n};\\n\\nfunction run(args) {\\n  args = args || arguments_;\\n\\n  if (runDependencies > 0) {\\n    return;\\n  }\\n\\n  preRun();\\n  if (runDependencies > 0) return;\\n\\n  function doRun() {\\n    if (calledRun) return;\\n    calledRun = true;\\n    Module[\\\"calledRun\\\"] = true;\\n    if (ABORT) return;\\n    initRuntime();\\n    preMain();\\n    if (Module[\\\"onRuntimeInitialized\\\"]) Module[\\\"onRuntimeInitialized\\\"]();\\n    postRun();\\n  }\\n\\n  if (Module[\\\"setStatus\\\"]) {\\n    Module[\\\"setStatus\\\"](\\\"Running...\\\");\\n    setTimeout(function () {\\n      setTimeout(function () {\\n        Module[\\\"setStatus\\\"](\\\"\\\");\\n      }, 1);\\n      doRun();\\n    }, 1);\\n  } else {\\n    doRun();\\n  }\\n}\\n\\nModule[\\\"run\\\"] = run;\\n\\nif (Module[\\\"preInit\\\"]) {\\n  if (typeof Module[\\\"preInit\\\"] == \\\"function\\\") Module[\\\"preInit\\\"] = [Module[\\\"preInit\\\"]];\\n\\n  while (Module[\\\"preInit\\\"].length > 0) {\\n    Module[\\\"preInit\\\"].pop()();\\n  }\\n}\\n\\nnoExitRuntime = true;\\nrun();\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","require(\"!!/Users/alexander/dev/telegram-tt/node_modules/script-loader/addScript.js\")(require(\"!!/Users/alexander/dev/telegram-tt/node_modules/raw-loader/index.js!/Users/alexander/dev/telegram-tt/node_modules/babel-loader/lib/index.js!/Users/alexander/dev/telegram-tt/src/lib/webp/webp_wasm.js\"))","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/* eslint-disable */\nimport 'script-loader!./webp_wasm';\n\nModule.onRuntimeInitialized = async () => {\n  self.postMessage({ type: 'initialized' });\n};\n\nself.onmessage = (event) => {\n  const { id, blob } = event.data;\n  const reader = new FileReader();\n\n  reader.addEventListener('loadend', () => {\n    const buffer = reader.result;\n\n    const size = buffer.byteLength;\n    const thisPtr = Module._malloc(size);\n    Module.HEAPU8.set(new Uint8Array(buffer), thisPtr);\n\n    const getInfo = Module.cwrap('getInfo', 'number', ['number', 'number']);\n\n    const ptr = getInfo(thisPtr, size);\n    const success = !!Module.getValue(ptr, 'i32');\n    if (!success) {\n      Module._free(ptr);\n      Module._free(thisPtr);\n      self.postMessage({\n        type: 'result', id, width: 0, height: 0, result: null,\n      });\n      return;\n    }\n    const width = Module.getValue(ptr + 4, 'i32');\n    const height = Module.getValue(ptr + 8, 'i32');\n\n    Module._free(ptr);\n\n    const decode = Module.cwrap('decode', 'number', ['number', 'number']);\n\n    const resultPtr = decode(thisPtr, size);\n\n    const resultView = new Uint8Array(Module.HEAPU8.buffer, resultPtr, width * height * 4);\n    const result = new Uint8ClampedArray(resultView);\n    Module._free(resultPtr);\n    Module._free(thisPtr);\n\n    self.postMessage({\n      type: 'result', id, width, height, result,\n    });\n  });\n\n  reader.readAsArrayBuffer(blob);\n};\n"],"names":["module","exports","src","log","error","console","execScript","attachEvent","addEventListener","eval","call","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","Module","onRuntimeInitialized","async","self","postMessage","type","onmessage","event","id","blob","data","reader","FileReader","buffer","result","size","byteLength","thisPtr","_malloc","HEAPU8","set","Uint8Array","ptr","cwrap","getInfo","getValue","_free","width","height","resultPtr","decode","resultView","Uint8ClampedArray","readAsArrayBuffer"],"sourceRoot":""}